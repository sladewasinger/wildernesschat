(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))s(e);new MutationObserver(e=>{for(const o of e)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(e){const o={};return e.integrity&&(o.integrity=e.integrity),e.referrerPolicy&&(o.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?o.credentials="include":e.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(e){if(e.ep)return;e.ep=!0;const o=n(e);fetch(e.href,o)}})();const A=(c,t)=>Math.floor(c/t),x=(c,t,n)=>Math.max(t,Math.min(n,c)),w=(c,t,n)=>c+(t-c)*n,W=(c,t,n)=>{if(c===t)return n<c?0:1;const s=x((n-c)/(t-c),0,1);return s*s*(3-2*s)};class pt{constructor(t,n,s){this.input={up:!1,down:!1,left:!1,right:!1},this.playerX=0,this.playerY=0,this.lastTime=0,this.resize=()=>{this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight},this.onKeyDown=o=>{this.toggleDebugLayer(o)||((o.key==="w"||o.key==="ArrowUp")&&(this.input.up=!0),(o.key==="s"||o.key==="ArrowDown")&&(this.input.down=!0),(o.key==="a"||o.key==="ArrowLeft")&&(this.input.left=!0),(o.key==="d"||o.key==="ArrowRight")&&(this.input.right=!0))},this.onKeyUp=o=>{(o.key==="w"||o.key==="ArrowUp")&&(this.input.up=!1),(o.key==="s"||o.key==="ArrowDown")&&(this.input.down=!1),(o.key==="a"||o.key==="ArrowLeft")&&(this.input.left=!1),(o.key==="d"||o.key==="ArrowRight")&&(this.input.right=!1)},this.tick=o=>{const i=this.lastTime===0?0:Math.min(.05,(o-this.lastTime)/1e3);this.lastTime=o,this.update(i),this.render(),requestAnimationFrame(this.tick)},this.canvas=t,this.hud=n,this.world=s;const e=t.getContext("2d");if(!e)throw new Error("2D canvas context unavailable.");this.ctx=e,this.ctx.imageSmoothingEnabled=!1,window.addEventListener("resize",this.resize),window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp),this.resize()}start(){requestAnimationFrame(this.tick)}update(t){let n=0,s=0;if(this.input.left&&(n-=1),this.input.right&&(n+=1),this.input.up&&(s-=1),this.input.down&&(s+=1),n!==0||s!==0){const o=Math.hypot(n,s);n/=o,s/=o}const e=210;this.playerX+=n*e*t,this.playerY+=s*e*t,this.world.advanceGenerationBudget()}render(){const t=this.ctx,n=this.world.getChunkSize(),s=this.canvas.width*.5,e=this.canvas.height*.5,o=A(this.playerX-s,n)-1,i=A(this.playerX+s,n)+1,r=A(this.playerY-e,n)-1,h=A(this.playerY+e,n)+1;t.clearRect(0,0,this.canvas.width,this.canvas.height);for(let f=r;f<=h;f+=1)for(let u=o;u<=i;u+=1){const p=this.world.getChunkCanvas(u,f),m=Math.floor(u*n-this.playerX+s),y=Math.floor(f*n-this.playerY+e);t.drawImage(p,m,y,n,n)}const g=this.world.sampleAt(this.playerX,this.playerY),l=this.world.getDebugLayers(),a=this.world.getGenerationStats(),d=this.world.getWorldHandshake();t.fillStyle="#f4eec7",t.beginPath(),t.arc(s,e,6,0,Math.PI*2),t.fill(),t.strokeStyle="#1e252d",t.lineWidth=2,t.stroke(),this.hud.textContent=["Organic village generator (phase 0-7 systems implemented)","Move: WASD / Arrows","Debug: 1 water 2 moisture 3 forest 4 contours 5 rivers 6 roads 7 villages 8 houses 9 parcels","Mask modes (1/2/3) hide roads/parcels/houses/trees for readability",`Seed: ${this.world.getSeed()}`,`Handshake: v${d.protocolVersion} hash=${d.configHash}`,`Player px: ${this.playerX.toFixed(1)}, ${this.playerY.toFixed(1)}`,`Chunk: ${A(this.playerX,n)}, ${A(this.playerY,n)}`,`Elev: ${g.elevation.toFixed(3)} Moisture: ${g.moisture.toFixed(3)}`,`Slope: ${g.slope.toFixed(3)} Forest: ${g.forestDensity.toFixed(3)}`,`Water depth: ${g.waterDepth.toFixed(3)}`,`Streaming: pendingChunks=${a.pendingChunks} seamWarnings=${a.seamWarnings}`,`Layers: water=${l.showWaterMask?"on":"off"} moisture=${l.showMoisture?"on":"off"} forest=${l.showForestMask?"on":"off"} contours=${l.showContours?"on":"off"} rivers=${l.showRivers?"on":"off"} roads=${l.showRoads?"on":"off"} villages=${l.showVillages?"on":"off"} parcels=${l.showParcels?"on":"off"} houses=${l.showHouses?"on":"off"}`].join(`
`)}toggleDebugLayer(t){return t.repeat?!0:t.key==="1"?(this.world.toggleDebugLayer("showWaterMask"),!0):t.key==="2"?(this.world.toggleDebugLayer("showMoisture"),!0):t.key==="3"?(this.world.toggleDebugLayer("showForestMask"),!0):t.key==="4"?(this.world.toggleDebugLayer("showContours"),!0):t.key==="5"?(this.world.toggleDebugLayer("showRivers"),!0):t.key==="6"?(this.world.toggleDebugLayer("showRoads"),!0):t.key==="7"?(this.world.toggleDebugLayer("showVillages"),!0):t.key==="8"?(this.world.toggleDebugLayer("showHouses"),!0):t.key==="9"?(this.world.toggleDebugLayer("showParcels"),!0):!1}}const mt=c=>({seed:c,terrain:{elevationFrequency:.0018,elevationOctaves:5,elevationPersistence:.53,elevationLacunarity:2.1,continentalFrequency:34e-5,seaLevel:.49,shoreBand:.06,warpFrequency:.0012,warpAmplitude:120,moistureFrequency:.0017,moistureOctaves:4,moisturePersistence:.58,moistureLacunarity:2.05,contourInterval:.048,contourStrength:.18,riverRegionSize:1100,riverSeedsPerRegion:2,riverStartElevation:.6,riverStepLength:18,riverMaxSteps:110},vegetation:{treeGridSize:18,treeRenderMargin:24,forestMinDensity:.3,forestDenseThreshold:.58,treeMinRadius:3.2,treeMaxRadius:8.2},settlement:{cellSize:360,minVillageDistance:300,suitabilityThreshold:.47,targetMoisture:.5,maxCoastSearch:420,preferredCoastMin:90,preferredCoastMax:280},roads:{regionSize:1800,nearestNeighbors:3,maxConnectionDistance:900,loopChance:.12,majorWidth:3.2,minorWidth:2.2,localWidth:1.5,routeStep:80,maxCurvatureOffset:56},houses:{spacing:24,sideChance:.79,minSetback:9,maxSetback:16,minWidth:10,maxWidth:18,minDepth:8,maxDepth:14,maxSlope:.26},chunk:{pixelSize:320,maxCachedChunks:196,sampleStep:2,featureMargin:140,superchunkSpanChunks:3,maxCachedSuperchunks:80,generationBudgetMs:2.8,maxChunkBuildsPerFrame:1,enableSeamValidation:!1,seamColorTolerance:22},debug:{showContours:!1,showRivers:!0,showWaterMask:!1,showMoisture:!1,showForestMask:!1,showRoads:!0,showVillages:!1,showParcels:!1,showHouses:!0}}),yt=2166136261,wt=16777619,V=c=>{let t=yt;for(let n=0;n<c.length;n+=1)t^=c.charCodeAt(n),t=Math.imul(t,wt);return t>>>0},H=c=>{let t=c>>>0;return t^=t>>>16,t=Math.imul(t,2146121005),t^=t>>>15,t=Math.imul(t,2221713035),t^=t>>>16,t>>>0},P=(c,t,n,s=0)=>{const e=Math.imul(t|0,2654435761),o=Math.imul(n|0,2246822507),i=Math.imul(s|0,3266489909);return H((c^e^o^i)>>>0)},k=c=>(c>>>0)/4294967295,st=c=>{let t=c>>>0;return t===0&&(t=1),{next:()=>{t+=1831565813;let n=t;return n=Math.imul(n^n>>>15,n|1),n^=n+Math.imul(n^n>>>7,n|61),((n^n>>>14)>>>0)/4294967296}}},bt=(c,t)=>`${c},${t}`,Mt=(c,t,n,s,e)=>{for(const o of c)if(o.x>=t&&o.x<=n&&o.y>=s&&o.y<=e)return!0;return!1};class ht{constructor(t,n){this.regionCache=new Map,this.maxCachedRegions=512,this.config=t,this.terrain=n,this.regionSeed=V(`${t.seed}:rivers`)}getRiversForBounds(t,n,s,e){const o=this.config.terrain.riverRegionSize,i=Math.floor(t/o)-1,r=Math.floor(n/o)+1,h=Math.floor(s/o)-1,g=Math.floor(e/o)+1,l=[];for(let a=h;a<=g;a+=1)for(let d=i;d<=r;d+=1){const f=this.getRegion(d,a);for(const u of f)Mt(u.points,t,n,s,e)&&l.push(u)}return l}getRegion(t,n){const s=bt(t,n),e=this.regionCache.get(s);if(e)return e;const o=this.generateRegion(t,n);return this.regionCache.set(s,o),this.pruneCache(),o}generateRegion(t,n){const s=this.config.terrain.riverRegionSize,e=t*s,o=n*s,i=P(this.regionSeed,t,n),r=st(i),h=[];for(let g=0;g<this.config.terrain.riverSeedsPerRegion;g+=1){let l=null,a=-1;for(let f=0;f<12;f+=1){const u=e+r.next()*s,p=o+r.next()*s,m=this.terrain.sample(u,p);if(m.waterDepth>-.015)continue;const y=m.elevation-m.shore*.25;y>a&&(a=y,l={x:u,y:p})}if(!l||a<this.config.terrain.riverStartElevation)continue;const d=this.traceRiver(l.x,l.y,st(P(i,g,91)));if(d.length>10){const f=this.config.roads.majorWidth*(2.2+r.next()*.8);h.push({points:d,width:f})}}return h}traceRiver(t,n,s){const e=this.config.terrain.riverStepLength,o=this.config.terrain.riverMaxSteps,i=[{x:t,y:n}];let r=t,h=n,g=Math.cos(s.next()*Math.PI*2),l=Math.sin(s.next()*Math.PI*2),a=!1,d=this.terrain.sample(r,h).elevation;for(let f=0;f<o;f+=1){const u=this.terrain.gradientAt(r,h,5);let p=-u.x,m=-u.y;const y=Math.hypot(p,m);if(y<1e-5){const S=s.next()*Math.PI*2;p=Math.cos(S),m=Math.sin(S)}else p/=y,m/=y;p=g*.52+p*.48,m=l*.52+m*.48;const b=Math.hypot(p,m);b>0&&(p/=b,m/=b),g=p,l=m,r+=p*e,h+=m*e;const M=this.terrain.sample(r,h);if(M.elevation>d+.012)break;if(d=M.elevation,i.push({x:r,y:h}),M.waterDepth>.002&&f>8){a=!0;break}if(i.length>18){const S=i[i.length-12],C=r-S.x,D=h-S.y;if(C*C+D*D<e*e*2.5)return[]}if(i.length>10)for(let S=0;S<i.length-6;S+=1){const C=r-i[S].x,D=h-i[S].y;if(C*C+D*D<e*e*.65)return[]}}return a?i.reverse():[]}clear(){this.regionCache.clear()}pruneCache(){if(this.regionCache.size<=this.maxCachedRegions)return;const t=this.regionCache.size-this.maxCachedRegions,n=this.regionCache.keys();for(let s=0;s<t;s+=1){const e=n.next();if(e.done)break;this.regionCache.delete(e.value)}}}const St=(c,t)=>`${c},${t}`,z=(c,t,n,s,e,o)=>c>=n&&c<=s&&t>=e&&t<=o,Ct=(c,t,n,s,e)=>{for(const o of c.points)if(z(o.x,o.y,t,n,s,e))return!0;return!1},kt=c=>{let t=0;for(let s=1;s<c.points.length;s+=1){const e=c.points[s].x-c.points[s-1].x,o=c.points[s].y-c.points[s-1].y;t+=Math.hypot(e,o)}if(t<1)return c.points[0];let n=t*.5;for(let s=1;s<c.points.length;s+=1){const e=c.points[s-1],o=c.points[s],i=Math.hypot(o.x-e.x,o.y-e.y);if(n<=i){const r=n/i;return{x:w(e.x,o.x,r),y:w(e.y,o.y,r)}}n-=i}return c.points[c.points.length-1]},xt=(c,t)=>`v-${c},${t}`,vt=(c,t)=>c<t?`${c}|${t}`:`${t}|${c}`,Rt=c=>`r-${c}`,ot=(c,t)=>`rl-${c}-${t}`,Dt=(c,t,n)=>`rlb-${c}-${t}-${n}`,$t=(c,t,n,s)=>`p-${c}-${t}-${n}-${s}`,Pt=c=>`h-${c}`;class Ft{constructor(t,n,s){this.config=t,this.terrain=n,this.houseSeed=s}generateHouses(t){const n=[];for(const s of t){const e=this.houseSeed^V(s.id);if(!this.shouldPlaceHouse(s,e))continue;const o=s.width*w(.62,.9,k(P(e,2,3,79))),i=s.depth*w(.5,.84,k(P(e,3,2,83))),r=(s.depth-i)*.35,h=Math.cos(s.angle+Math.PI*.5),g=Math.sin(s.angle+Math.PI*.5),l=s.x-h*s.side*r,a=s.y-g*s.side*r,d=this.terrain.probe(l,a);if(d.waterDepth>.001||d.slope>this.config.houses.maxSlope)continue;const f=(k(P(e,5,1,89))*2-1)*.08,u=Math.floor(k(P(e,7,11,97))*4);n.push({id:Pt(s.id),x:l,y:a,width:o,depth:i,angle:s.angle+f,roofStyle:u})}return n}shouldPlaceHouse(t,n){const s=k(P(n,1,1,67)),e=t.roadType==="major"?.46:t.roadType==="minor"?.72:.88;return s<=e}}class Wt{constructor(t,n,s){this.config=t,this.terrain=n,this.parcelSeed=s}generateParcels(t,n){const s=[],e=new Map,o=new Map,i=11;for(const r of n)e.set(r.id,r),o.set(r.id,0);for(const r of t){const h=r.type==="major"?1.6:r.type==="minor"?1.25:1,g=this.config.houses.spacing*h;for(let l=1;l<r.points.length;l+=1){const a=r.points[l-1],d=r.points[l],f=d.x-a.x,u=d.y-a.y,p=Math.hypot(f,u);if(p<g*.65)continue;const m=f/p,y=u/p,b=-y,M=m,S=Math.floor(p/g);for(let C=1;C<S;C+=1){const D=C/S,L=w(a.x,d.x,D),I=w(a.y,d.y,D),$=this.pickVillageForRoadPosition(r,D,e);if($&&this.shouldKeepForVillageDensity(r,L,I,$))for(const v of[-1,1]){const T=V(`${r.id}:${l}:${C}:${v}`);if(!this.shouldSpawnParcel(T,r.type))continue;const F=o.get($.id)??0;if(F>=140)continue;const q=k(P(this.parcelSeed^T,l,C,43)),O=k(P(this.parcelSeed^T,l,C,47)),G=k(P(this.parcelSeed^T,l,C,53)),et=w(this.config.houses.minWidth*1.1,this.config.houses.maxWidth*1.5,q),E=w(this.config.houses.minDepth*1.5,this.config.houses.maxDepth*2,O),K=w(this.config.houses.minSetback,this.config.houses.maxSetback,G)+r.width*.5,j=L+b*v*(K+E*.5),Y=I+M*v*(K+E*.5),J=this.terrain.probe(j,Y);J.waterDepth>.002||J.slope>this.config.houses.maxSlope||!s.every(X=>{const ft=X.x-j,gt=X.y-Y;return Math.hypot(ft,gt)>=i})||(s.push({id:$t(r.id,l,C,v),villageId:$.id,roadId:r.id,roadType:r.type,x:j,y:Y,width:et,depth:E,angle:Math.atan2(y,m),side:v}),o.set($.id,F+1))}}}}return s}shouldSpawnParcel(t,n){const s=k(P(this.parcelSeed^t,3,7,61)),e=n==="major"?this.config.houses.sideChance*.25:n==="minor"?this.config.houses.sideChance*.58:this.config.houses.sideChance*.95;return s<=e}shouldKeepForVillageDensity(t,n,s,e){if(t.type==="local")return!0;const o=Math.hypot(n-e.x,s-e.y),i=t.type==="minor"?e.radius*2.8:e.radius*2.1;return o<=i}pickVillageForRoadPosition(t,n,s){const e=s.get(t.fromVillageId),o=s.get(t.toVillageId);return t.fromVillageId===t.toVillageId?e??null:n<.5?e??o??null:o??e??null}}class It{constructor(t){this.parent=new Array(t),this.rank=new Array(t);for(let n=0;n<t;n+=1)this.parent[n]=n,this.rank[n]=0}find(t){return this.parent[t]!==t&&(this.parent[t]=this.find(this.parent[t])),this.parent[t]}union(t,n){const s=this.find(t),e=this.find(n);return s===e?!1:(this.rank[s]<this.rank[e]?this.parent[s]=e:this.rank[s]>this.rank[e]?this.parent[e]=s:(this.parent[e]=s,this.rank[s]+=1),!0)}}class Vt{constructor(t,n,s){this.config=t,this.terrain=n,this.roadSeed=s}buildRegionalRoadNetwork(t){if(t.length<2)return[];const n=new Map;for(let a=0;a<t.length;a+=1)n.set(t[a].id,a);const s=new Map;for(let a=0;a<t.length;a+=1){const d=t[a],f=[];for(let p=0;p<t.length;p+=1){if(a===p)continue;const m=t[p],y=m.x-d.x,b=m.y-d.y,M=Math.hypot(y,b);M>this.config.roads.maxConnectionDistance||f.push({village:m,distance:M})}f.sort((p,m)=>p.distance-m.distance);const u=Math.min(this.config.roads.nearestNeighbors,f.length);for(let p=0;p<u;p+=1){const m=f[p].village,y=vt(d.id,m.id);if(!s.has(y)){const b=f[p].distance,M=this.estimateConnectionCost(d,m,b);s.set(y,{a:d,b:m,id:y,weight:M,distance:b})}}}const e=Array.from(s.values()).sort((a,d)=>a.weight-d.weight),o=new It(t.length),i=new Map,r=[];for(const a of e){const d=n.get(a.a.id),f=n.get(a.b.id);d===void 0||f===void 0||(o.union(d,f)?i.set(a.id,a):r.push(a))}const h=Math.floor(t.length*.28);let g=0;for(const a of r){if(g>=h)break;const d=k(P(this.roadSeed,a.a.cellX+a.b.cellX,a.a.cellY+a.b.cellY,199)),f=this.config.roads.loopChance*x(1-a.distance/this.config.roads.maxConnectionDistance,.25,1);d<f&&(i.set(a.id,a),g+=1)}const l=[];for(const a of i.values()){const d=a.distance>this.config.roads.maxConnectionDistance*.55?"major":"minor",f=d==="major"?this.config.roads.majorWidth:this.config.roads.minorWidth;l.push({id:Rt(a.id),type:d,width:f,points:this.routeRoad(a.a,a.b,a.id),fromVillageId:a.a.id,toVillageId:a.b.id})}return l}buildLocalRoadNetwork(t,n){const s=[],e=[...n];for(const o of t){const i=V(`${this.config.seed}:local-road:${o.id}`),r=this.estimateVillageAxis(o,n,i),h=Math.cos(r),g=Math.sin(r),l=-g,a=h,d=x(o.radius*.5,24,44),f=Math.max(7,d*.34),u=this.nearestRegionalRoadToVillage(o,n);if(u&&u.distance<o.radius*1.8){const b=this.createConnectorLine(o.x,o.y,u.pointX,u.pointY,k(P(i,991,0,911)));if(this.isRoadLineValid(b)&&this.isRoadLineDistinct(b,e,Math.max(6,this.config.roads.localWidth*2.5))){const M={id:ot(o.id,0),type:"local",width:this.config.roads.localWidth,points:b,fromVillageId:o.id,toVillageId:o.id};s.push(M),e.push(M)}}const p=o.radius>86?[-.85,0,.85]:[-.55,0];let m=1;for(const b of p){const M=k(P(i,b+7,0,433)),S=this.createStreetLine(o.x,o.y,h,g,l,a,o.radius*w(1.35,1.95,M),b*d,M);if(!this.isRoadLineValid(S)||!this.isRoadLineDistinct(S,e,f))continue;const C={id:ot(o.id,m),type:"local",width:this.config.roads.localWidth,points:S,fromVillageId:o.id,toVillageId:o.id};s.push(C),e.push(C),m+=1}const y=o.radius>92?[-.45,.45]:[0];for(let b=0;b<y.length;b+=1){const M=k(P(i,b,0,541));if(y.length>1&&M<.22)continue;const S=this.createStreetLine(o.x,o.y,l,a,h,g,o.radius*w(.95,1.45,M),y[b]*d*1.2,M);if(!this.isRoadLineValid(S)||!this.isRoadLineDistinct(S,e,f))continue;const C={id:Dt(o.id,b,0),type:"local",width:this.config.roads.localWidth*.92,points:S,fromVillageId:o.id,toVillageId:o.id};s.push(C),e.push(C)}}return s}estimateVillageAxis(t,n,s){const e=this.nearestRegionalRoadToVillage(t,n);return e?Math.atan2(e.tangentY,e.tangentX):k(P(s,t.cellX,t.cellY,83))*Math.PI*2}nearestRegionalRoadToVillage(t,n){let s=Number.POSITIVE_INFINITY,e=1,o=0,i=t.x,r=t.y;for(const h of n)if(!(h.points.length<2))for(let g=1;g<h.points.length;g+=1){const l=h.points[g-1],a=h.points[g],d=this.closestPointOnSegment(t.x,t.y,l.x,l.y,a.x,a.y);if(d.distance>=s)continue;s=d.distance,i=d.x,r=d.y;const f=a.x-l.x,u=a.y-l.y,p=Math.hypot(f,u);p>1e-6&&(e=f/p,o=u/p)}return Number.isFinite(s)?{distance:s,tangentX:e,tangentY:o,pointX:i,pointY:r}:null}createStreetLine(t,n,s,e,o,i,r,h,g){const l=(g*2-1)*r*.12,a=t+o*h,d=n+i*h,f={x:a-s*r+o*l,y:d-e*r+i*l},u={x:a+s*r-o*l,y:d+e*r-i*l},p={x:a+o*l*.4,y:d+i*l*.4};return[f,p,u]}createConnectorLine(t,n,s,e,o){const i=s-t,r=e-n,h=Math.hypot(i,r);if(h<=1e-6)return[{x:t,y:n},{x:s,y:e}];const g=i/h,a=-(r/h),d=g,f=(o*2-1)*Math.min(18,h*.18);return[{x:t,y:n},{x:w(t,s,.5)+a*f,y:w(n,e,.5)+d*f},{x:s,y:e}]}closestPointOnSegment(t,n,s,e,o,i){const r=o-s,h=i-e,g=r*r+h*h;if(g<=1e-6){const f=t-s,u=n-e;return{x:s,y:e,distance:Math.hypot(f,u)}}const l=x(((t-s)*r+(n-e)*h)/g,0,1),a=s+r*l,d=e+h*l;return{x:a,y:d,distance:Math.hypot(t-a,n-d)}}isRoadLineDistinct(t,n,s){if(t.length<2)return!1;const e=t[0],o=t[t.length-1],i=o.x-e.x,r=o.y-e.y,h=Math.hypot(i,r);if(h<=1e-6)return!1;const g=t[Math.floor(t.length*.5)];for(const l of n)for(let a=1;a<l.points.length;a+=1){const d=l.points[a-1],f=l.points[a],u=f.x-d.x,p=f.y-d.y,m=Math.hypot(u,p);if(m<=1e-6||Math.abs((i*u+r*p)/(h*m))<.86)continue;if(this.closestPointOnSegment(g.x,g.y,d.x,d.y,f.x,f.y).distance<=s)return!1}return!0}estimateConnectionCost(t,n,s){const e=Math.max(3,Math.round(s/110));let o=0;for(let i=1;i<e;i+=1){const r=i/e,h=this.terrain.probe(w(t.x,n.x,r),w(t.y,n.y,r));h.waterDepth>0&&(o+=3+h.waterDepth*12),o+=h.slope*.75}return s*(1+o/e)}routeRoad(t,n,s){const e=n.x-t.x,o=n.y-t.y,i=Math.hypot(e,o),r=Math.max(3,Math.round(i/this.config.roads.routeStep)),h=i>0?e/i:1,l=-(i>0?o/i:0),a=h,d=[],f=V(`edge:${s}`);for(let u=0;u<=r;u+=1){const p=u/r,m=w(t.x,n.x,p),y=w(t.y,n.y,p),b=Math.sin(p*Math.PI),M=k(P(f,u,r,67))*2-1,S=this.config.roads.maxCurvatureOffset*b*(.35+i/this.config.roads.maxConnectionDistance*.65);d.push({x:m+l*S*M,y:y+a*S*M})}d[0]={x:t.x,y:t.y},d[d.length-1]={x:n.x,y:n.y},this.smoothLine(d,2);for(let u=0;u<2;u+=1)for(let p=1;p<d.length-1;p+=1){const m=this.terrain.sample(d[p].x,d[p].y);if(m.waterDepth<=.003)continue;const y=this.terrain.gradientAt(d[p].x,d[p].y,5),b=Math.hypot(y.x,y.y);if(b<1e-4)continue;const M=10+m.waterDepth*95;d[p].x+=y.x/b*M,d[p].y+=y.y/b*M}return d[0]={x:t.x,y:t.y},d[d.length-1]={x:n.x,y:n.y},d}smoothLine(t,n){for(let s=0;s<n;s+=1)for(let e=1;e<t.length-1;e+=1)t[e]={x:t[e-1].x*.25+t[e].x*.5+t[e+1].x*.25,y:t[e-1].y*.25+t[e].y*.5+t[e+1].y*.25}}isRoadLineValid(t){for(let n=1;n<t.length;n+=1)if(this.terrain.sample(t[n].x,t[n].y).waterDepth>.007)return!1;return!0}}class Ht{constructor(t,n,s){this.candidateCache=new Map,this.maxCachedCandidates=28e3,this.config=t,this.terrain=n,this.villageSeed=s}collectVillagesInBounds(t,n,s,e){const o=this.config.settlement.cellSize,i=Math.floor(t/o)-1,r=Math.floor(n/o)+1,h=Math.floor(s/o)-1,g=Math.floor(e/o)+1,l=[];for(let a=h;a<=g;a+=1)for(let d=i;d<=r;d+=1){const f=this.villageAtCell(d,a);f&&f.x>=t&&f.x<=n&&f.y>=s&&f.y<=e&&l.push(f)}return l}clear(){this.candidateCache.clear()}villageAtCell(t,n){const s=this.candidateAt(t,n);if(s.score<this.config.settlement.suitabilityThreshold)return null;const e=this.config.settlement.minVillageDistance,o=e*e,i=Math.max(1,Math.ceil(e/this.config.settlement.cellSize)+1);for(let g=n-i;g<=n+i;g+=1)for(let l=t-i;l<=t+i;l+=1){if(l===t&&g===n)continue;const a=this.candidateAt(l,g);if(a.score<this.config.settlement.suitabilityThreshold)continue;const d=a.x-s.x,f=a.y-s.y;if(!(d*d+f*f>o)&&(a.score>s.score||a.score===s.score&&a.tieBreaker>s.tieBreaker))return null}const r=k(P(this.villageSeed,t,n,223)),h=w(44,92,x(s.score*.65+r*.35,0,1));return{id:s.id,x:s.x,y:s.y,score:s.score,radius:h,cellX:t,cellY:n}}candidateAt(t,n){const s=`${t},${n}`,e=this.candidateCache.get(s);if(e)return e;const o=this.config.settlement.cellSize,i=P(this.villageSeed,t,n,41),r=k(H(i^2654435769)),h=k(H(i^2135587861)),g=(t+r)*o,l=(n+h)*o,a=this.terrain.probe(g,l),d=k(H(i^2715316799));let f=0;if(a.waterDepth<=.003){const p=this.estimateCoastDistance(g,l),m=1-W(.08,.62,a.slope),y=Math.abs(a.moisture-this.config.settlement.targetMoisture),b=1-x(y/.46,0,1),M=this.coastPreferenceFactor(p),S=W(.64,.92,a.forestDensity)*.24,C=W(.92,.99,a.shore)*.35,D=W(.78,.98,a.elevation)*.2,L=.7+k(H(i^1114599283))*.45;f=(m*.42+b*.23+M*.35)*L,f-=S+C+D,f=x(f,0,1)}const u={id:xt(t,n),cellX:t,cellY:n,x:g,y:l,score:f,tieBreaker:d};return this.candidateCache.set(s,u),this.pruneCandidateCache(),u}coastPreferenceFactor(t){const n=this.config.settlement.preferredCoastMin,s=this.config.settlement.preferredCoastMax,e=this.config.settlement.maxCoastSearch;return t<=n?x(t/n,0,1):t<=s?1:x(1-(t-s)/Math.max(1,e-s),0,1)}estimateCoastDistance(t,n){const s=this.config.settlement.maxCoastSearch,e=10,o=22;let i=s;for(let r=0;r<e;r+=1){const h=Math.PI*2*r/e,g=Math.cos(h),l=Math.sin(h);for(let a=o;a<=s;a+=o)if(this.terrain.sample(t+g*a,n+l*a).waterDepth>0){a<i&&(i=a);break}}return i}pruneCandidateCache(){if(this.candidateCache.size<=this.maxCachedCandidates)return;const t=this.candidateCache.size-this.maxCachedCandidates,n=this.candidateCache.keys();for(let s=0;s<t;s+=1){const e=n.next();if(e.done)break;this.candidateCache.delete(e.value)}}}class lt{constructor(t,n){this.regionCache=new Map,this.maxCachedRegions=220,this.config=t;const s=V(`${t.seed}:villages`),e=V(`${t.seed}:roads`),o=V(`${t.seed}:parcels`),i=V(`${t.seed}:houses`);this.villageGenerator=new Ht(t,n,s),this.roadGenerator=new Vt(t,n,e),this.parcelGenerator=new Wt(t,n,o),this.houseGenerator=new Ft(t,n,i)}getFeaturesForBounds(t,n,s,e){const o=this.config.roads.regionSize,i=Math.floor(t/o)-1,r=Math.floor(n/o)+1,h=Math.floor(s/o)-1,g=Math.floor(e/o)+1,l=new Map,a=new Map,d=new Map,f=new Map;for(let u=h;u<=g;u+=1)for(let p=i;p<=r;p+=1){const m=this.getRegion(p,u);for(const y of m.villages)z(y.x,y.y,t,n,s,e)&&l.set(y.id,y);for(const y of m.roads)Ct(y,t,n,s,e)&&a.set(y.id,y);for(const y of m.parcels)z(y.x,y.y,t,n,s,e)&&d.set(y.id,y);for(const y of m.houses)z(y.x,y.y,t,n,s,e)&&f.set(y.id,y)}return{villages:Array.from(l.values()),roads:Array.from(a.values()),parcels:Array.from(d.values()),houses:Array.from(f.values())}}clear(){this.regionCache.clear(),this.villageGenerator.clear()}getRegion(t,n){const s=St(t,n),e=this.regionCache.get(s);if(e)return e;const o=this.generateRegion(t,n);return this.regionCache.set(s,o),this.pruneRegionCache(),o}generateRegion(t,n){const s=this.config.roads.regionSize,e=t*s,o=n*s,i=e+s,r=o+s,h=this.config.roads.maxConnectionDistance+this.config.settlement.cellSize,g=this.villageGenerator.collectVillagesInBounds(e-h,i+h,o-h,r+h),l=this.roadGenerator.buildRegionalRoadNetwork(g),a=this.roadGenerator.buildLocalRoadNetwork(g,l),d=[...l,...a],f=this.parcelGenerator.generateParcels(d,g),u=this.houseGenerator.generateHouses(f),p=g.filter(M=>z(M.x,M.y,e,i,o,r)),m=d.filter(M=>{const S=kt(M);return z(S.x,S.y,e,i,o,r)}),y=f.filter(M=>z(M.x,M.y,e,i,o,r)),b=u.filter(M=>z(M.x,M.y,e,i,o,r));return{villages:p,roads:m,parcels:y,houses:b}}pruneRegionCache(){if(this.regionCache.size<=this.maxCachedRegions)return;const t=this.regionCache.size-this.maxCachedRegions,n=this.regionCache.keys();for(let s=0;s<t;s+=1){const e=n.next();if(e.done)break;this.regionCache.delete(e.value)}}}const it=c=>c*c*(3-2*c),Z=(c,t,n)=>k(P(c,t,n)),Tt=(c,t,n)=>{const s=Math.floor(t),e=Math.floor(n),o=s+1,i=e+1,r=it(t-s),h=it(n-e),g=Z(c,s,e),l=Z(c,o,e),a=Z(c,s,i),d=Z(c,o,i),f=w(g,l,r),u=w(a,d,r);return w(f,u,h)},U=(c,t,n,s)=>{let e=1,o=1,i=0,r=0;for(let h=0;h<s.octaves;h+=1)i+=Tt(c+h*1013,t*o,n*o)*e,r+=e,e*=s.persistence,o*=s.lacunarity;return r>0?i/r:0},Lt=c=>({elevation:V(`${c}:terrain:elevation`),continental:V(`${c}:terrain:continental`),warpX:V(`${c}:terrain:warpX`),warpY:V(`${c}:terrain:warpY`),moisture:V(`${c}:terrain:moisture`)}),Nt=c=>({elevation:{octaves:c.terrain.elevationOctaves,persistence:c.terrain.elevationPersistence,lacunarity:c.terrain.elevationLacunarity},moisture:{octaves:c.terrain.moistureOctaves,persistence:c.terrain.moisturePersistence,lacunarity:c.terrain.moistureLacunarity}}),tt=c=>{const t=Lt(c.seed),n=Nt(c),s=(l,a)=>{const d=(U(t.warpX,l*c.terrain.warpFrequency,a*c.terrain.warpFrequency,{octaves:3,persistence:.54,lacunarity:2.15})*2-1)*c.terrain.warpAmplitude,f=(U(t.warpY,(l+271.3)*c.terrain.warpFrequency,(a-194.8)*c.terrain.warpFrequency,{octaves:3,persistence:.54,lacunarity:2.15})*2-1)*c.terrain.warpAmplitude,u=l+d,p=a+f,m=U(t.elevation,u*c.terrain.elevationFrequency,p*c.terrain.elevationFrequency,n.elevation),y=U(t.continental,l*c.terrain.continentalFrequency,a*c.terrain.continentalFrequency,{octaves:4,persistence:.58,lacunarity:2}),b=x(m*.64+y*.36,0,1),M=b*b*(3-2*b);return x(M,0,1)},e=(l,a,d,f)=>{const u=U(t.moisture,(l+5e3)*c.terrain.moistureFrequency,(a-2800)*c.terrain.moistureFrequency,n.moisture),p=f*.33,m=d>0?.19:0;return x(u*.72+p+m,0,1)},o=(l,a)=>{const d=s(l,a),f=c.terrain.seaLevel-d,u=1-x(Math.abs(f)/c.terrain.shoreBand,0,1),p=e(l,a,f,u);return{elevation:d,moisture:p,waterDepth:f,shore:u}},i=(l,a,d=3)=>{const f=(s(l+d,a)-s(l-d,a))/(2*d),u=(s(l,a+d)-s(l,a-d))/(2*d);return{x:f,y:u}},r=(l,a)=>{const d=i(l,a,5);return x(Math.hypot(d.x,d.y)*60,0,1)},h=(l,a)=>{const d=o(l,a);if(d.waterDepth>.012)return 0;const f=r(l,a),u=W(.28,.9,d.moisture),p=1-W(.22,.78,f),m=W(.6,.95,d.shore)*.3,y=W(.76,.98,d.elevation)*.35;return x(u*.73+p*.34-m-y,0,1)};return{sample:o,probe:(l,a)=>{const d=o(l,a),f=r(l,a),u=h(l,a);return{...d,slope:f,forestDensity:u}},gradientAt:i,slopeAt:r,forestDensityAt:h}},nt=c=>{if(Array.isArray(c))return c.map(nt);if(c&&typeof c=="object"){const t=Object.entries(c).sort(([s],[e])=>s.localeCompare(e)),n={};for(const[s,e]of t)n[s]=nt(e);return n}return c},At=c=>({terrain:{...c.terrain},vegetation:{...c.vegetation},settlement:{...c.settlement},roads:{...c.roads},houses:{...c.houses}}),dt=c=>JSON.stringify(nt(c)),Bt=c=>(V(c)>>>0).toString(16).padStart(8,"0"),qt=(c,t)=>Bt(dt({seed:c,generationConfig:t})),ut=c=>{const t=At(c);return{protocolVersion:1,seed:c.seed,generationConfig:t,configHash:qt(c.seed,t)}},Ot=c=>dt(c),Q=c=>(V(c)>>>0).toString(16).padStart(8,"0"),R=(c,t=4)=>c.toFixed(t),zt=c=>{const t=tt(c),n=[];for(let s=-6;s<=6;s+=1)for(let e=-6;e<=6;e+=1){const o=e*73.25+s%3*11.7,i=s*68.5+e%4*9.3,r=t.probe(o,i);n.push(`${R(r.elevation)}|${R(r.moisture)}|${R(r.waterDepth)}|${R(r.slope)}|${R(r.forestDensity)}`)}return Q(n.join(";"))},Gt=c=>{const t=tt(c),n=new ht(c,t).getRiversForBounds(-1900,1900,-1900,1900).slice();n.sort((e,o)=>{var l,a,d,f;const i=((l=e.points[0])==null?void 0:l.x)??0,r=((a=e.points[0])==null?void 0:a.y)??0,h=((d=o.points[0])==null?void 0:d.x)??0,g=((f=o.points[0])==null?void 0:f.y)??0;return i===h?r-g:i-h});const s=n.map(e=>{const o=e.points.slice(0,14).map(i=>`${R(i.x,2)},${R(i.y,2)}`).join("|");return`${R(e.width,3)}:${o}`});return Q(s.join(";"))},Et=c=>{const t=tt(c),s=new lt(c,t).getFeaturesForBounds(-1850,1850,-1850,1850),e=s.villages.slice().sort((u,p)=>u.id.localeCompare(p.id)),o=s.roads.slice().sort((u,p)=>u.id.localeCompare(p.id)),i=s.parcels.slice().sort((u,p)=>u.id.localeCompare(p.id)),r=s.houses.slice().sort((u,p)=>u.id.localeCompare(p.id)),h=e.map(u=>`${u.id}:${R(u.x,2)},${R(u.y,2)},${R(u.score,4)},${R(u.radius,2)}`),g=o.map(u=>{const p=u.points[0],m=u.points[u.points.length-1];return`${u.id}:${u.type}:${R(u.width,2)}:${R((p==null?void 0:p.x)??0,2)},${R((p==null?void 0:p.y)??0,2)}>${R((m==null?void 0:m.x)??0,2)},${R((m==null?void 0:m.y)??0,2)}`}),l=i.map(u=>`${u.id}:${u.roadId}:${R(u.x,2)},${R(u.y,2)},${R(u.width,2)},${R(u.depth,2)},${R(u.angle,4)}`),a=r.map(u=>`${u.id}:${R(u.x,2)},${R(u.y,2)},${R(u.width,2)},${R(u.depth,2)},${R(u.angle,4)},${u.roofStyle}`),d=Q([...h,...g,...l,...a].join(";")),f=Q([...e.map(u=>u.id),...o.map(u=>u.id),...i.map(u=>u.id),...r.map(u=>u.id)].join("|"));return{coreHash:d,idHash:f}},jt=c=>{const t=ut(c),n=zt(c),s=Gt(c),e=Et(c),o=Q([t.configHash,n,s,e.coreHash,e.idHash].join("/"));return{protocolVersion:t.protocolVersion,seed:c.seed,configHash:t.configHash,digests:{terrainHash:n,riversHash:s,settlementsHash:e.coreHash,stableIdHash:e.idHash,overallHash:o}}},Yt=(c,t=3)=>{const n=[];for(let o=0;o<Math.max(1,t);o+=1)n.push(jt(c));const s=n[0].digests.overallHash;return{consistent:n.every(o=>o.digests.overallHash===s),runs:n}};class Kt{constructor(t,n,s,e){this.config=t,this.terrain=n,this.debug=s,this.seedHash=e}sample(t,n,s){if(this.debug.showWaterMask)return s.waterDepth>.001?{r:84,g:144,b:212}:s.shore>.48?{r:188,g:210,b:175}:{r:159,g:191,b:145};if(this.debug.showMoisture){const v=x(s.moisture,0,1);if(v<.33){const F=v/.33;return{r:w(25,52,F),g:w(45,122,F),b:w(120,112,F)}}if(v<.66){const F=(v-.33)/.33;return{r:w(52,116,F),g:w(122,178,F),b:w(112,64,F)}}const T=(v-.66)/.34;return{r:w(116,222,T),g:w(178,201,T),b:w(64,78,T)}}if(this.debug.showForestMask){const v=this.terrain.forestDensityAt(t,n);return{r:w(18,95,v),g:w(27,198,v),b:w(22,74,v)}}const e=(k(P(this.seedHash,t,n,77))-.5)*7,o=W(.18,.87,s.elevation),i=W(.1,.92,s.moisture);let r=w(132,173,o)-i*17,h=w(167,196,o)-i*11,g=w(122,156,o)-i*18;this.debug.showContours&&this.config.terrain.contourInterval>0&&s.elevation/this.config.terrain.contourInterval%1<this.config.terrain.contourStrength&&(r-=18,h-=18,g-=18);const l=s.shore*.42;r=w(r,193,l),h=w(h,198,l),g=w(g,165,l),r+=e,h+=e,g+=e;const a=x(s.waterDepth/Math.max(this.config.terrain.shoreBand*1.8,.001),0,1),d=W(.22,1,a);let f=w(86,74,d),u=w(147,131,d),p=w(214,199,d);const m=e*.16;f+=m,u+=m,p+=m;const y=this.sampleWaterCoverage(t,n,s),b=x(y,0,1);let M=w(r,f,b),S=w(h,u,b),C=w(g,p,b);const D=1-Math.abs(y*2-1),L=1-W(.003,.02,s.waterDepth),I=W(.8,1,y),$=Math.max(D,W(.82,.99,s.shore)*L*I);return M=w(M,27,$*.44),S=w(S,52,$*.44),C=w(C,80,$*.44),{r:M,g:S,b:C}}sampleWaterCoverage(t,n,s){if(s.shore<.22)return s.waterDepth>0?1:0;let e=0;const o=[-.28,.28];for(let i=0;i<o.length;i+=1)for(let r=0;r<o.length;r+=1)this.terrain.sample(t+o[r],n+o[i]).waterDepth>0&&(e+=1);return e/4}}const rt=12,N={field:{base:.21,ringWeight:.56,roadWeight:.24,moistureWeight:.14,forestPenaltyWeight:.5,shorePenaltyWeight:.15,slopePenaltyWeight:.31,roadStart:16},forest:{villagePenaltyWeight:.62,roadPenaltyWeight:.52,fieldPressureWeight:.58,shorePenaltyWeight:.24,moistureWeight:.05,roadStart:14}};class Xt{constructor(t,n,s){this.roadDistanceCache=new Map,this.villageDistanceCache=new Map,this.config=t,this.terrain=n,this.features=s}fieldSuitabilityForVillage(t,n,s){const e=this.terrain.probe(t,n);if(e.waterDepth>.001||e.slope>.36)return 0;const o=Math.hypot(t-s.x,n-s.y),i=s.radius*1.7,r=Math.max(s.radius*.85,1),h=x(1-Math.abs(o-i)/r,0,1),g=this.nearestRoadDistance(t,n),l=Math.max(this.config.settlement.minVillageDistance*.5,92),a=Number.isFinite(g)?1-W(N.field.roadStart,l,g):0,d=W(.55,.84,e.forestDensity),f=W(.6,.96,e.shore),u=W(.28,.76,e.moisture);return x(N.field.base+h*N.field.ringWeight+a*N.field.roadWeight+u*N.field.moistureWeight-d*N.field.forestPenaltyWeight-f*N.field.shorePenaltyWeight-e.slope*N.field.slopePenaltyWeight,0,1)}forestSuitability(t,n,s){if(s<=0)return 0;const e=this.terrain.probe(t,n);if(e.waterDepth>.012)return 0;const o=this.nearestVillageInfo(t,n),i=this.nearestRoadDistance(t,n),r=Math.max(this.config.settlement.minVillageDistance*.22,55),h=Math.max(this.config.settlement.minVillageDistance*1.05,r+80),g=Number.isFinite(o.distance)?1-W(r,h,o.distance):0,l=Math.max(this.config.settlement.minVillageDistance*.34,96),a=Number.isFinite(i)?1-W(N.forest.roadStart,l,i):0,d=W(.58,.97,e.shore)*N.forest.shorePenaltyWeight,f=this.fieldPressure(o,i),u=s*(1-g*N.forest.villagePenaltyWeight-a*N.forest.roadPenaltyWeight-f*N.forest.fieldPressureWeight)*(1-d)+e.moisture*N.forest.moistureWeight;return x(u,0,1)}fieldPressure(t,n){if(!Number.isFinite(t.distance)||t.radius<=0||!Number.isFinite(n))return 0;const s=t.radius*.96,e=t.radius*2.55;if(t.distance<s||t.distance>e)return 0;const o=(s+e)*.5,i=Math.max((e-s)*.5,1),r=x(1-Math.abs(t.distance-o)/i,0,1),h=1-W(22,Math.max(this.config.settlement.minVillageDistance*.44,140),n);return x(r*h,0,1)}nearestVillageInfo(t,n){const s=this.cacheKey(t,n),e=this.villageDistanceCache.get(s);if(e)return e;let o=Number.POSITIVE_INFINITY,i=0;for(const h of this.features.villages){const g=Math.hypot(t-h.x,n-h.y);g<o&&(o=g,i=h.radius)}const r={distance:o,radius:i};return this.villageDistanceCache.set(s,r),r}nearestRoadDistance(t,n){const s=this.cacheKey(t,n),e=this.roadDistanceCache.get(s);if(e!==void 0)return e;let o=Number.POSITIVE_INFINITY;for(const i of this.features.roads)for(let r=1;r<i.points.length;r+=1){const h=i.points[r-1],g=i.points[r],l=this.distanceToSegment(t,n,h.x,h.y,g.x,g.y)-i.width;l<o&&(o=l)}return this.roadDistanceCache.set(s,o),o}distanceToSegment(t,n,s,e,o,i){const r=o-s,h=i-e,g=r*r+h*h;if(g<=1e-6)return Math.hypot(t-s,n-e);const l=x(((t-s)*r+(n-e)*h)/g,0,1),a=s+r*l,d=e+h*l;return Math.hypot(t-a,n-d)}cacheKey(t,n){return`${Math.floor(t/rt)},${Math.floor(n/rt)}`}}const Ut=(c,t)=>`${c},${t}`;class Qt{constructor(t,n){this.cache=new Map,this.config=t,this.settlements=n}getFeaturesForChunk(t,n){const s=Math.max(1,this.config.chunk.superchunkSpanChunks|0),e=Math.floor(t/s),o=Math.floor(n/s),i=Ut(e,o),r=this.cache.get(i);if(r)return r.features;const h=this.config.chunk.pixelSize,g=s*h,l=e*g,a=o*g,d=l+g,f=a+g,u=this.config.chunk.featureMargin,p=this.settlements.getFeaturesForBounds(l-u,d+u,a-u,f+u);return this.cache.set(i,{key:i,features:p}),this.prune(),p}clear(){this.cache.clear()}prune(){const t=this.config.chunk.maxCachedSuperchunks;if(this.cache.size<=t)return;const n=this.cache.size-t,s=this.cache.keys();for(let e=0;e<n;e+=1){const o=s.next();if(o.done)break;this.cache.delete(o.value)}}}class Jt{constructor(t,n,s,e,o,i,r){this.config=t,this.terrain=n,this.rivers=s,this.debug=o,this.treeSeed=i,this.fieldSeed=r,this.superchunkCache=new Qt(t,e)}draw(t,n,s,e,o,i){const r=this.getRiversForChunk(e,o,i);if(this.debug.showWaterMask||this.debug.showMoisture||this.debug.showForestMask){this.debug.showRivers&&this.drawRivers(t,e,o,r);return}this.drawRivers(t,e,o,r);const g=this.superchunkCache.getFeaturesForChunk(n,s),l=new Xt(this.config,this.terrain,g);this.drawFields(t,e,o,i,g,l),this.drawRoadsAndVillages(t,e,o,g,r),this.drawParcels(t,e,o,g.parcels),this.drawHouses(t,e,o,g),this.drawForest(t,e,o,i,l)}getRiversForChunk(t,n,s){const o=t-28,i=t+s+28,r=n-28,h=n+s+28;return this.rivers.getRiversForBounds(o,i,r,h)}drawRivers(t,n,s,e){if(this.debug.showRivers){for(const o of e)if(!(o.points.length<2)){t.beginPath(),t.moveTo(o.points[0].x-n,o.points[0].y-s);for(let i=1;i<o.points.length;i+=1)t.lineTo(o.points[i].x-n,o.points[i].y-s);t.lineCap="round",t.lineJoin="round",t.strokeStyle="rgba(9, 16, 24, 0.9)",t.lineWidth=o.width+2.8,t.stroke(),t.strokeStyle="rgba(97, 169, 205, 0.9)",t.lineWidth=o.width,t.stroke()}}}drawForest(t,n,s,e,o){const i=this.config.vegetation.treeGridSize,r=this.config.vegetation.treeRenderMargin,h=A(n-r,i),g=A(n+e+r,i),l=A(s-r,i),a=A(s+e+r,i),d=this.config.vegetation.forestDenseThreshold,f=this.config.vegetation.forestMinDensity,u=[],p=[];for(let m=l;m<=a;m+=1)for(let y=h;y<=g;y+=1){const b=P(this.treeSeed,y,m),M=k(H(b^2779993889)),S=k(H(b^4046232899)),C=y*i+M*i,D=m*i+S*i,L=this.terrain.forestDensityAt(C,D),I=o.forestSuitability(C,D,L);if(I<f)continue;const $=x((I-f)/(1-f),0,1);if(k(H(b^1831565813))>$*$)continue;const T=k(H(b^2654435769)),F=w(this.config.vegetation.treeMinRadius,this.config.vegetation.treeMaxRadius,I)*(.8+T*.5),q=k(H(b^1327217884)),O=C-n,G=D-s;I>=d?u.push({x:O,y:G,radius:F,alpha:x(.32+I*.34,.2,.7),shape:q}):p.push({x:O,y:G,radius:F*.72,alpha:x(.42+I*.3,.25,.7),shape:q})}for(const m of u)this.drawTreeSymbol(t,m.x,m.y,m.radius,m.shape,`rgba(83, 122, 103, ${m.alpha.toFixed(3)})`);t.lineWidth=1;for(const m of p)this.drawTreeSymbol(t,m.x,m.y,m.radius,m.shape,`rgba(126, 169, 145, ${m.alpha.toFixed(3)})`)}drawFields(t,n,s,e,o,i){const l=e+44,a=e+44,d=18;for(const f of o.villages){const u=f.radius*1.08,p=f.radius*2.28;for(let m=0;m<d;m+=1){const y=P(this.fieldSeed,f.cellX*97+m*13,f.cellY*89+m*17),b=k(y)*Math.PI*2,M=w(u,p,k(H(y^2654435769))),S=w(-20,20,k(H(y^2135587861))),C=f.x+Math.cos(b)*M+Math.cos(b+Math.PI*.5)*S,D=f.y+Math.sin(b)*M+Math.sin(b+Math.PI*.5)*S,L=i.fieldSuitabilityForVillage(C,D,f);if(L<.22||k(H(y^461845907))>L)continue;const $=w(26,68,k(H(y^3518319157))),v=w(16,40,k(H(y^2496678331))),T=Math.max($,v)*.55+7;if(this.pointNearRoad(C,D,o.roads,T))continue;const F=C-n,q=D-s;if(F<-44||q<-44||F>l||q>a)continue;const O=k(H(y^2246822507)),G=k(H(y^3266489909)),et=b+w(-.6,.6,k(H(y^668265263))),E=Math.round(w(173,208,O)),K=Math.round(w(162,194,O)),j=Math.round(w(126,148,O));t.save(),t.translate(F,q),t.rotate(et),t.fillStyle=`rgba(${E}, ${K}, ${j}, 0.36)`,t.strokeStyle=`rgba(${Math.max(0,E-70)}, ${Math.max(0,K-62)}, ${Math.max(0,j-48)}, 0.56)`,t.lineWidth=1.3,t.fillRect(-$*.5,-v*.5,$,v),t.strokeRect(-$*.5,-v*.5,$,v);const Y=Math.max(2,Math.floor(v/6)),J=w(.22,.36,G);t.strokeStyle=`rgba(104, 84, 52, ${J.toFixed(3)})`,t.lineWidth=1.1;for(let _=1;_<Y;_+=1){const X=-v*.5+v*_/Y;t.beginPath(),t.moveTo(-$*.45,X),t.lineTo($*.45,X),t.stroke()}t.restore()}}}drawTreeSymbol(t,n,s,e,o,i){const r=Math.max(2.4,e),h=4+Math.floor(o*3),g=o*Math.PI*2,l=Math.max(2,r*.45),a=Math.max(1.2,r*.26);t.fillStyle="rgba(19, 27, 24, 0.24)",t.beginPath(),t.ellipse(n+r*.24,s+r*.54,r*.72,r*.42,0,0,Math.PI*2),t.fill(),t.fillStyle="rgba(76, 59, 45, 0.9)",t.fillRect(n-a*.5,s+r*.18,a,l),t.fillStyle=i,t.beginPath();for(let d=0;d<h;d+=1){const f=g+d/h*Math.PI*2,u=r*(.8+(d+1)%2*.2),p=n+Math.cos(f)*u*.42,m=s-r*.1+Math.sin(f)*u*.35;d===0?t.moveTo(p,m):t.lineTo(p,m)}t.closePath(),t.fill(),t.strokeStyle="rgba(14, 18, 16, 0.9)",t.lineWidth=1.4,t.stroke()}pointNearRoad(t,n,s,e){const o=e*e;for(const i of s)for(let r=1;r<i.points.length;r+=1){const h=i.points[r-1],g=i.points[r],l=this.distanceSqToSegment(t,n,h.x,h.y,g.x,g.y),a=i.width+2;if(l<=o+a*a)return!0}return!1}distanceSqToSegment(t,n,s,e,o,i){const r=o-s,h=i-e,g=r*r+h*h;if(g<=1e-6){const p=t-s,m=n-e;return p*p+m*m}const l=x(((t-s)*r+(n-e)*h)/g,0,1),a=s+r*l,d=e+h*l,f=t-a,u=n-d;return f*f+u*u}drawRoadsAndVillages(t,n,s,e,o){if(!(!this.debug.showRoads&&!this.debug.showVillages)){if(this.debug.showRoads)for(const i of e.roads)i.points.length<2||this.drawRoadSegments(t,i,n,s,o);this.debug.showVillages&&this.drawVillageMarkers(t,n,s,e.villages)}}drawRoadSegments(t,n,s,e,o){let i=!1,r=!1;t.lineCap="round",t.lineJoin="round";for(let h=1;h<n.points.length;h+=1){const g=n.points[h-1],l=n.points[h];if(this.roadSegmentNearRiver(g.x,g.y,l.x,l.y,n.width,o)){i&&(this.strokeRoadPath(t,n),r=!0),i=!1;continue}const a=g.x-s,d=g.y-e,f=l.x-s,u=l.y-e;i||(t.beginPath(),t.moveTo(a,d),i=!0),t.lineTo(f,u)}i&&(this.strokeRoadPath(t,n),r=!0)}strokeRoadPath(t,n){t.strokeStyle="rgba(8, 10, 11, 0.88)",t.lineWidth=n.width+(n.type==="local"?2.2:2.9),t.stroke(),t.strokeStyle=n.type==="major"?"rgba(223, 211, 169, 0.98)":n.type==="minor"?"rgba(210, 201, 163, 0.96)":"rgba(205, 198, 170, 0.94)",t.lineWidth=n.width,t.stroke()}roadSegmentNearRiver(t,n,s,e,o,i){for(const r of i)for(let h=1;h<r.points.length;h+=1){const g=r.points[h-1],l=r.points[h],a=this.distanceSqToSegment(t,n,g.x,g.y,l.x,l.y),d=this.distanceSqToSegment(s,e,g.x,g.y,l.x,l.y),f=r.width*.46+o*.78;if(a<=f*f||d<=f*f)return!0}return!1}drawVillageMarkers(t,n,s,e){for(const o of e){const i=o.x-n,r=o.y-s,h=x(o.radius*.07,3,6);t.fillStyle="rgba(244, 230, 186, 0.92)",t.beginPath(),t.arc(i,r,h,0,Math.PI*2),t.fill(),t.strokeStyle="rgba(10, 14, 12, 0.9)",t.lineWidth=1.4,t.stroke(),t.beginPath(),t.moveTo(i-h*1.4,r),t.lineTo(i+h*1.4,r),t.moveTo(i,r-h*1.4),t.lineTo(i,r+h*1.4),t.lineWidth=1,t.stroke()}}drawParcels(t,n,s,e){if(this.debug.showParcels)for(const o of e){const i=o.x-n,r=o.y-s;t.save(),t.translate(i,r),t.rotate(o.angle),t.fillStyle="rgba(211, 218, 167, 0.28)",t.strokeStyle="rgba(11, 15, 13, 0.82)",t.lineWidth=1.2,t.fillRect(-o.width*.5,-o.depth*.5,o.width,o.depth),t.strokeRect(-o.width*.5,-o.depth*.5,o.width,o.depth),t.restore()}}drawHouses(t,n,s,e){if(this.debug.showHouses)for(const o of e.houses)this.drawHouse(t,n,s,o)}drawHouse(t,n,s,e){const o=e.x-n,i=e.y-s,r=[{roof:"#907367",wall:"#c3b59d"},{roof:"#6f7680",wall:"#b7b8b0"},{roof:"#8f6654",wall:"#c2b19e"},{roof:"#7d6f5f",wall:"#bbb09f"}],h=r[e.roofStyle%r.length];t.save(),t.translate(o,i),t.rotate(e.angle),t.fillStyle="rgba(25, 33, 38, 0.2)",t.fillRect(-e.width*.55+1.5,-e.depth*.5+2.5,e.width,e.depth),t.fillStyle=h.wall,t.strokeStyle="rgba(8, 10, 10, 0.9)",t.lineWidth=1.3,t.fillRect(-e.width*.5,-e.depth*.5,e.width,e.depth),t.strokeRect(-e.width*.5,-e.depth*.5,e.width,e.depth),t.fillStyle=h.roof,t.fillRect(-e.width*.6,-e.depth*.52,e.width*1.2,e.depth*.58),t.strokeRect(-e.width*.6,-e.depth*.52,e.width*1.2,e.depth*.58),t.strokeStyle="rgba(14, 11, 9, 0.64)",t.beginPath(),t.moveTo(-e.width*.55,-e.depth*.4),t.lineTo(e.width*.55,-e.depth*.4),t.stroke(),t.restore()}}const B=c=>Math.max(0,Math.min(255,Math.round(c)));class _t{constructor(t,n){this.terrain=t,this.colorSampler=n}render(t,n,s,e,o){if(o===1){this.renderFullResolution(t,n,s,e);return}this.renderBlockSampled(t,n,s,e,o)}renderFullResolution(t,n,s,e){const o=t.createImageData(e,e),i=o.data;let r=0;for(let h=0;h<e;h+=1)for(let g=0;g<e;g+=1){const l=n+g,a=s+h,d=this.terrain.sample(l,a),f=this.colorSampler.sample(l,a,d);i[r]=B(f.r),i[r+1]=B(f.g),i[r+2]=B(f.b),i[r+3]=255,r+=4}t.putImageData(o,0,0)}renderBlockSampled(t,n,s,e,o){const i=t.createImageData(e,e),r=i.data;for(let h=0;h<e;h+=o)for(let g=0;g<e;g+=o){const l=Math.min(o,e-g),a=Math.min(o,e-h),d=n+g+o*.5,f=s+h+o*.5,u=this.terrain.sample(d,f);if(u.shore>.14){for(let S=0;S<a;S+=1)for(let C=0;C<l;C+=1){const D=g+C,L=h+S,I=n+D+.5,$=s+L+.5,v=this.terrain.sample(I,$),T=this.colorSampler.sample(I,$,v),F=(L*e+D)*4;r[F]=B(T.r),r[F+1]=B(T.g),r[F+2]=B(T.b),r[F+3]=255}continue}const m=this.colorSampler.sample(d,f,u),y=B(m.r),b=B(m.g),M=B(m.b);for(let S=0;S<a;S+=1)for(let C=0;C<l;C+=1){const D=g+C,I=((h+S)*e+D)*4;r[I]=y,r[I+1]=b,r[I+2]=M,r[I+3]=255}}t.putImageData(i,0,0)}}class Zt{constructor(t,n,s,e,o,i,r,h){this.config=t;const g=new Kt(t,n,o,i);this.terrainSurface=new _t(n,g),this.overlays=new Jt(t,n,s,e,o,r,h)}renderChunk(t,n){const s=this.config.chunk.pixelSize,e=Math.max(1,this.config.chunk.sampleStep|0),o=t*s,i=n*s,r=document.createElement("canvas");r.width=s,r.height=s;const h=r.getContext("2d");if(!h)throw new Error("2D canvas context unavailable.");return this.terrainSurface.render(h,o,i,s,e),this.overlays.draw(h,t,n,o,i,s),r}}class te{constructor(t){this.warningCount=0,this.config=t}getWarningCount(){return this.warningCount}validate(t,n,s){if(!this.config.chunk.enableSeamValidation)return;const e=s(t,n);if(!e)return;const o=s(t-1,n);o&&this.compareVertical(o,e,t,n);const i=s(t,n-1);i&&this.compareHorizontal(i,e,t,n)}compareVertical(t,n,s,e){const o=this.config.chunk.seamColorTolerance,i=Math.min(t.width,n.width),r=Math.min(t.height,n.height);if(i<1||r<1)return;const h=t.getContext("2d"),g=n.getContext("2d");if(!h||!g)return;const l=h.getImageData(i-1,0,1,r).data,a=g.getImageData(0,0,1,r).data;let d=0;for(let u=0;u<l.length;u+=4)d+=Math.abs(l[u]-a[u]),d+=Math.abs(l[u+1]-a[u+1]),d+=Math.abs(l[u+2]-a[u+2]);const f=d/Math.max(1,r*3);f<=o||(this.warningCount+=1,this.warningCount<=14&&console.warn(`Seam mismatch (vertical) at chunk ${s-1},${e} -> ${s},${e}: avg RGB diff ${f.toFixed(2)}`))}compareHorizontal(t,n,s,e){const o=this.config.chunk.seamColorTolerance,i=Math.min(t.width,n.width),r=Math.min(t.height,n.height);if(i<1||r<1)return;const h=t.getContext("2d"),g=n.getContext("2d");if(!h||!g)return;const l=h.getImageData(0,r-1,i,1).data,a=g.getImageData(0,0,i,1).data;let d=0;for(let u=0;u<l.length;u+=4)d+=Math.abs(l[u]-a[u]),d+=Math.abs(l[u+1]-a[u+1]),d+=Math.abs(l[u+2]-a[u+2]);const f=d/Math.max(1,i*3);f<=o||(this.warningCount+=1,this.warningCount<=14&&console.warn(`Seam mismatch (horizontal) at chunk ${s},${e-1} -> ${s},${e}: avg RGB diff ${f.toFixed(2)}`))}}const at=(c,t)=>`${c},${t}`,ct=()=>typeof performance<"u"?performance.now():Date.now();class ee{constructor(t){this.chunkCache=new Map,this.pendingQueue=[],this.pendingSet=new Set,this.getReadyChunkCanvas=(r,h)=>{const g=this.chunkCache.get(at(r,h));return!g||g.status!=="ready"?null:g.canvas},this.config=t,this.terrain=tt(t);const n=new ht(t,this.terrain),s=new lt(t,this.terrain);this.debug={...t.debug};const e=V(`${t.seed}:surface`),o=V(`${t.seed}:trees`),i=V(`${t.seed}:fields`);this.chunkRenderer=new Zt(t,this.terrain,n,s,this.debug,e,o,i),this.seamValidator=new te(t),this.placeholderCanvas=this.createPlaceholderChunkCanvas(t.chunk.pixelSize)}getSeed(){return this.config.seed}getChunkSize(){return this.config.chunk.pixelSize}getDebugLayers(){return{...this.debug}}toggleDebugLayer(t){this.debug[t]=!this.debug[t],this.chunkCache.clear(),this.pendingSet.clear(),this.pendingQueue.length=0}sampleAt(t,n){return this.terrain.probe(t,n)}getWorldHandshake(){return ut(this.config)}getSerializedWorldHandshake(){return Ot(this.getWorldHandshake())}advanceGenerationBudget(){const t=Math.max(.2,this.config.chunk.generationBudgetMs),n=Math.max(1,this.config.chunk.maxChunkBuildsPerFrame|0),s=ct();let e=0;for(;e<n&&this.pendingQueue.length>0&&!(ct()-s>t);){const o=this.pendingQueue.shift();if(!o)break;this.pendingSet.delete(o);const i=this.chunkCache.get(o);!i||i.status==="ready"||(i.canvas=this.chunkRenderer.renderChunk(i.x,i.y),i.status="ready",e+=1,this.seamValidator.validate(i.x,i.y,this.getReadyChunkCanvas))}}getGenerationStats(){return{pendingChunks:this.pendingSet.size,seamWarnings:this.seamValidator.getWarningCount()}}getChunkCanvas(t,n){return this.getChunk(t,n).canvas}getChunk(t,n){const s=at(t,n),e=this.chunkCache.get(s);if(e)return e;const o={x:t,y:n,canvas:this.placeholderCanvas,status:"pending"};return this.chunkCache.set(s,o),this.enqueueChunkGeneration(s),this.pruneCache(),o}enqueueChunkGeneration(t){this.pendingSet.has(t)||(this.pendingSet.add(t),this.pendingQueue.push(t))}pruneCache(){const t=this.config.chunk.maxCachedChunks;if(this.chunkCache.size<=t)return;const n=this.chunkCache.size-t,s=this.chunkCache.keys();for(let e=0;e<n;e+=1){const o=s.next();if(o.done)break;const i=o.value;this.chunkCache.delete(i),this.pendingSet.delete(i)}}createPlaceholderChunkCanvas(t){const n=document.createElement("canvas");n.width=t,n.height=t;const s=n.getContext("2d");if(!s)return n;s.fillStyle="#8fa486",s.fillRect(0,0,t,t),s.strokeStyle="rgba(65, 76, 60, 0.36)",s.lineWidth=1;const e=16;for(let o=-t;o<t*2;o+=e)s.beginPath(),s.moveTo(o,0),s.lineTo(o-t,t),s.stroke();return n}}const ne=()=>{const c=document.querySelector("#game"),t=document.querySelector("#hud");if(!c||!t)throw new Error("Missing #game canvas or #hud element.");const n=new URLSearchParams(window.location.search),s=n.get("seed")??"12345abcde",e=Number(n.get("chunkSize")??"320"),o=Number(n.get("seaLevel")??"NaN"),i=Number(n.get("sampleStep")??"2"),r=Number(n.get("superchunkSpan")??"NaN"),h=Number(n.get("genBudgetMs")??"NaN"),g=Number(n.get("maxChunkBuilds")??"NaN"),l=n.get("seamValidation"),a=n.get("determinism"),d=Number(n.get("determinismRuns")??"3"),f=mt(s);Number.isFinite(e)&&e>=180&&e<=640&&(f.chunk.pixelSize=e),Number.isFinite(o)&&o>=.3&&o<=.68&&(f.terrain.seaLevel=o),Number.isFinite(i)&&i>=1&&i<=8&&(f.chunk.sampleStep=Math.floor(i)),Number.isFinite(r)&&r>=1&&r<=8&&(f.chunk.superchunkSpanChunks=Math.floor(r)),Number.isFinite(h)&&h>=.5&&h<=24&&(f.chunk.generationBudgetMs=h),Number.isFinite(g)&&g>=1&&g<=8&&(f.chunk.maxChunkBuildsPerFrame=Math.floor(g)),l==="0"||l==="false"?f.chunk.enableSeamValidation=!1:(l==="1"||l==="true")&&(f.chunk.enableSeamValidation=!0);const u=new ee(f);if(a==="1"||a==="true"){const m=Yt(f,Number.isFinite(d)?d:3);console.info("Determinism suite result",m)}new pt(c,t,u).start()};try{ne()}catch(c){const t=c instanceof Error?c.message:String(c);document.body.innerHTML=`<pre style="color:#fff;padding:16px">${t}</pre>`}
