(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))e(n);new MutationObserver(n=>{for(const o of n)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&e(i)}).observe(document,{childList:!0,subtree:!0});function s(n){const o={};return n.integrity&&(o.integrity=n.integrity),n.referrerPolicy&&(o.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?o.credentials="include":n.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function e(n){if(n.ep)return;n.ep=!0;const o=s(n);fetch(n.href,o)}})();const H=(g,t)=>Math.floor(g/t),D=(g,t,s)=>Math.max(t,Math.min(s,g)),x=(g,t,s)=>g+(t-g)*s,N=(g,t,s)=>{if(g===t)return s<g?0:1;const e=D((s-g)/(t-g),0,1);return e*e*(3-2*e)};class mt{constructor(t,s,e){this.input={up:!1,down:!1,left:!1,right:!1},this.playerX=0,this.playerY=0,this.lastTime=0,this.resize=()=>{this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight},this.onKeyDown=o=>{(o.key==="w"||o.key==="ArrowUp")&&(this.input.up=!0),(o.key==="s"||o.key==="ArrowDown")&&(this.input.down=!0),(o.key==="a"||o.key==="ArrowLeft")&&(this.input.left=!0),(o.key==="d"||o.key==="ArrowRight")&&(this.input.right=!0)},this.onKeyUp=o=>{(o.key==="w"||o.key==="ArrowUp")&&(this.input.up=!1),(o.key==="s"||o.key==="ArrowDown")&&(this.input.down=!1),(o.key==="a"||o.key==="ArrowLeft")&&(this.input.left=!1),(o.key==="d"||o.key==="ArrowRight")&&(this.input.right=!1)},this.tick=o=>{const i=this.lastTime===0?0:Math.min(.05,(o-this.lastTime)/1e3);this.lastTime=o,this.update(i),this.render(),requestAnimationFrame(this.tick)},this.canvas=t,this.hud=s,this.world=e;const n=t.getContext("2d");if(!n)throw new Error("2D canvas context unavailable.");this.ctx=n,this.ctx.imageSmoothingEnabled=!1,window.addEventListener("resize",this.resize),window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp),this.resize()}start(){requestAnimationFrame(this.tick)}update(t){let s=0,e=0;if(this.input.left&&(s-=1),this.input.right&&(s+=1),this.input.up&&(e-=1),this.input.down&&(e+=1),s!==0||e!==0){const o=Math.hypot(s,e);s/=o,e/=o}const n=210;this.playerX+=s*n*t,this.playerY+=e*n*t,this.world.prefetchChunksNearPlayer(this.playerX,this.playerY,this.canvas.width,this.canvas.height,s,e),this.world.advanceGenerationBudget()}render(){const t=this.ctx,s=this.world.getChunkSize(),e=this.canvas.width*.5,n=this.canvas.height*.5,o=H(this.playerX-e,s)-1,i=H(this.playerX+e,s)+1,r=H(this.playerY-n,s)-1,c=H(this.playerY+n,s)+1;t.clearRect(0,0,this.canvas.width,this.canvas.height);for(let p=r;p<=c;p+=1)for(let m=o;m<=i;m+=1){const y=this.world.getChunkCanvas(m,p),M=Math.floor(m*s-this.playerX+e),w=Math.floor(p*s-this.playerY+n);t.drawImage(y,M,w,s,s)}const l=this.world.sampleAt(this.playerX,this.playerY),d=this.world.getGenerationStats(),a=this.world.getWorldHandshake();t.fillStyle="#f4eec7",t.beginPath(),t.arc(e,n,6,0,Math.PI*2),t.fill(),t.strokeStyle="#1e252d",t.lineWidth=2,t.stroke();const h=(this.input.right?1:0)-(this.input.left?1:0),f=(this.input.down?1:0)-(this.input.up?1:0),u=Math.hypot(h,f)>0?1:0;this.hud.textContent=["Village Generator","Move: WASD / Arrows",`Seed: ${this.world.getSeed()}`,`Handshake: v${a.protocolVersion} hash=${a.configHash}`,`Player px: ${this.playerX.toFixed(1)}, ${this.playerY.toFixed(1)}`,`Movement: ${u?"moving":"idle"}`,`Chunk: ${H(this.playerX,s)}, ${H(this.playerY,s)}`,`Terrain: elev=${l.elevation.toFixed(3)} moist=${l.moisture.toFixed(3)} slope=${l.slope.toFixed(3)} water=${l.waterDepth.toFixed(3)}`,`Streaming: pending=${d.pendingChunks} seamWarnings=${d.seamWarnings}`].join(`
`)}}const yt=g=>({seed:g,terrain:{elevationFrequency:.0018,elevationOctaves:5,elevationPersistence:.53,elevationLacunarity:2.1,continentalFrequency:34e-5,seaLevel:.49,shoreBand:.06,warpFrequency:.0012,warpAmplitude:120,moistureFrequency:.0017,moistureOctaves:4,moisturePersistence:.58,moistureLacunarity:2.05,contourInterval:.048,contourStrength:.18,riverRegionSize:1100,riverSeedsPerRegion:2,riverStartElevation:.6,riverStepLength:18,riverMaxSteps:110},vegetation:{treeGridSize:18,treeRenderMargin:24,forestMinDensity:.3,forestDenseThreshold:.58,treeMinRadius:3.2,treeMaxRadius:8.2},settlement:{cellSize:360,minVillageDistance:300,suitabilityThreshold:.47,targetMoisture:.5,maxCoastSearch:420,preferredCoastMin:90,preferredCoastMax:280},roads:{regionSize:1800,nearestNeighbors:3,maxConnectionDistance:900,loopChance:.12,majorWidth:3.2,minorWidth:2.2,localWidth:1.5,routeStep:80,maxCurvatureOffset:56},houses:{spacing:24,sideChance:.79,minSetback:9,maxSetback:16,minWidth:10,maxWidth:18,minDepth:8,maxDepth:14,maxSlope:.26},chunk:{pixelSize:320,maxCachedChunks:196,sampleStep:2,featureMargin:140,superchunkSpanChunks:3,maxCachedSuperchunks:80,generationBudgetMs:2.8,maxChunkBuildsPerFrame:1,prefetchLookaheadChunks:2,prefetchLateralChunks:1,enableSeamValidation:!1,seamColorTolerance:22},debug:{showContours:!1,showRivers:!0,showWaterMask:!1,showMoisture:!1,showForestMask:!1,showRoads:!0,showVillages:!1,showParcels:!1,showHouses:!0}}),xt=2166136261,bt=16777619,B=g=>{let t=xt;for(let s=0;s<g.length;s+=1)t^=g.charCodeAt(s),t=Math.imul(t,bt);return t>>>0},V=g=>{let t=g>>>0;return t^=t>>>16,t=Math.imul(t,2146121005),t^=t>>>15,t=Math.imul(t,2221713035),t^=t>>>16,t>>>0},I=(g,t,s,e=0)=>{const n=Math.imul(t|0,2654435761),o=Math.imul(s|0,2246822507),i=Math.imul(e|0,3266489909);return V((g^n^o^i)>>>0)},R=g=>(g>>>0)/4294967295,ot=g=>{let t=g>>>0;return t===0&&(t=1),{next:()=>{t+=1831565813;let s=t;return s=Math.imul(s^s>>>15,s|1),s^=s+Math.imul(s^s>>>7,s|61),((s^s>>>14)>>>0)/4294967296}}},Mt=(g,t)=>`${g},${t}`,wt=(g,t,s,e,n)=>{for(const o of g)if(o.x>=t&&o.x<=s&&o.y>=e&&o.y<=n)return!0;return!1};class lt{constructor(t,s){this.regionCache=new Map,this.maxCachedRegions=512,this.config=t,this.terrain=s,this.regionSeed=B(`${t.seed}:rivers`)}getRiversForBounds(t,s,e,n){const o=this.config.terrain.riverRegionSize,i=Math.floor(t/o)-1,r=Math.floor(s/o)+1,c=Math.floor(e/o)-1,l=Math.floor(n/o)+1,d=[];for(let a=c;a<=l;a+=1)for(let h=i;h<=r;h+=1){const f=this.getRegion(h,a);for(const u of f)wt(u.points,t,s,e,n)&&d.push(u)}return d}getRegion(t,s){const e=Mt(t,s),n=this.regionCache.get(e);if(n)return n;const o=this.generateRegion(t,s);return this.regionCache.set(e,o),this.pruneCache(),o}generateRegion(t,s){const e=this.config.terrain.riverRegionSize,n=t*e,o=s*e,i=I(this.regionSeed,t,s),r=ot(i),c=[];for(let l=0;l<this.config.terrain.riverSeedsPerRegion;l+=1){let d=null,a=-1;for(let f=0;f<12;f+=1){const u=n+r.next()*e,p=o+r.next()*e,m=this.terrain.sample(u,p);if(m.waterDepth>-.015)continue;const y=m.elevation-m.shore*.25;y>a&&(a=y,d={x:u,y:p})}if(!d||a<this.config.terrain.riverStartElevation)continue;const h=this.traceRiver(d.x,d.y,ot(I(i,l,91)));if(h.length>10){const f=this.config.roads.majorWidth*(2.2+r.next()*.8);c.push({points:h,width:f})}}return c}traceRiver(t,s,e){const n=this.config.terrain.riverStepLength,o=this.config.terrain.riverMaxSteps,i=[{x:t,y:s}];let r=t,c=s,l=Math.cos(e.next()*Math.PI*2),d=Math.sin(e.next()*Math.PI*2),a=!1,h=this.terrain.sample(r,c).elevation;for(let f=0;f<o;f+=1){const u=this.terrain.gradientAt(r,c,5);let p=-u.x,m=-u.y;const y=Math.hypot(p,m);if(y<1e-5){const b=e.next()*Math.PI*2;p=Math.cos(b),m=Math.sin(b)}else p/=y,m/=y;p=l*.52+p*.48,m=d*.52+m*.48;const M=Math.hypot(p,m);M>0&&(p/=M,m/=M),l=p,d=m,r+=p*n,c+=m*n;const w=this.terrain.sample(r,c);if(w.elevation>h+.012)break;if(h=w.elevation,i.push({x:r,y:c}),w.waterDepth>.002&&f>8){a=!0;break}if(i.length>18){const b=i[i.length-12],C=r-b.x,v=c-b.y;if(C*C+v*v<n*n*2.5)return[]}if(i.length>10)for(let b=0;b<i.length-6;b+=1){const C=r-i[b].x,v=c-i[b].y;if(C*C+v*v<n*n*.65)return[]}}return a?i.reverse():[]}clear(){this.regionCache.clear()}pruneCache(){if(this.regionCache.size<=this.maxCachedRegions)return;const t=this.regionCache.size-this.maxCachedRegions,s=this.regionCache.keys();for(let e=0;e<t;e+=1){const n=s.next();if(n.done)break;this.regionCache.delete(n.value)}}}const kt=(g,t)=>`${g},${t}`,z=(g,t,s,e,n,o)=>g>=s&&g<=e&&t>=n&&t<=o,Ct=(g,t,s,e,n)=>{for(const o of g.points)if(z(o.x,o.y,t,s,e,n))return!0;return!1},St=g=>{let t=0;for(let e=1;e<g.points.length;e+=1){const n=g.points[e].x-g.points[e-1].x,o=g.points[e].y-g.points[e-1].y;t+=Math.hypot(n,o)}if(t<1)return g.points[0];let s=t*.5;for(let e=1;e<g.points.length;e+=1){const n=g.points[e-1],o=g.points[e],i=Math.hypot(o.x-n.x,o.y-n.y);if(s<=i){const r=s/i;return{x:x(n.x,o.x,r),y:x(n.y,o.y,r)}}s-=i}return g.points[g.points.length-1]},vt=(g,t)=>`v-${g},${t}`,Rt=(g,t)=>g<t?`${g}|${t}`:`${t}|${g}`,Dt=g=>`r-${g}`,it=(g,t)=>`rl-${g}-${t}`,Pt=(g,t,s)=>`rlb-${g}-${t}-${s}`,$t=(g,t,s,e)=>`p-${g}-${t}-${s}-${e}`,It=g=>`h-${g}`,Ft=(g,t)=>`rn-${g}-${t}`,Tt=(g,t)=>`rnb-${g}-${t}`,Lt=g=>`re-${g}`;class Nt{constructor(t,s,e,n,o,i){this.config=t,this.terrain=s,this.villageGenerator=e,this.roadGenerator=n,this.parcelGenerator=o,this.houseGenerator=i}buildRegionLayout(t,s){const e=this.config.roads.regionSize,n=t*e,o=s*e,i=n+e,r=o+e,c=this.config.roads.maxConnectionDistance+this.config.settlement.cellSize,l=this.villageGenerator.collectVillagesInBounds(n-c,i+c,o-c,r+c).slice().sort((k,S)=>k.id.localeCompare(S.id)),d=this.roadGenerator.buildRegionalRoadNetwork(l),a=this.roadGenerator.buildLocalRoadNetwork(l,d),h=[...d,...a].sort((k,S)=>k.id.localeCompare(S.id)),f=this.parcelGenerator.generateParcels(h,l).slice().sort((k,S)=>k.id.localeCompare(S.id)),u=this.houseGenerator.generateHouses(f).slice().sort((k,S)=>k.id.localeCompare(S.id)),p=this.buildRoadGraph(l,h),m=l.filter(k=>z(k.x,k.y,n,i,o,r)),y=h.filter(k=>{const S=St(k);return z(S.x,S.y,n,i,o,r)}),M=new Set(y.map(k=>k.id)),w=p.roadEdges.filter(k=>M.has(k.roadId)).slice().sort((k,S)=>k.id.localeCompare(S.id)),b=new Set;for(const k of w){b.add(k.fromNodeId),b.add(k.toNodeId);for(const S of k.bridgeNodeIds)b.add(S)}const C=p.roadNodes.filter(k=>b.has(k.id)||z(k.x,k.y,n,i,o,r)).slice().sort((k,S)=>k.id.localeCompare(S.id)),v=f.filter(k=>z(k.x,k.y,n,i,o,r)),$=u.filter(k=>z(k.x,k.y,n,i,o,r));return{villages:m,roadNodes:C,roadEdges:w,roads:y,parcels:v,houses:$}}buildRoadGraph(t,s){const e=new Map,n=[],o=new Map(t.map(i=>[i.id,i]));for(const i of t)e.set(i.id,{id:i.id,kind:"village",x:i.x,y:i.y,villageId:i.id});for(const i of s){if(i.points.length<2)continue;const r=i.points[0],c=i.points[i.points.length-1],l=this.endpointNodeId(e,o,i.id,"start",i.fromVillageId,r.x,r.y),d=this.endpointNodeId(e,o,i.id,"end",i.toVillageId,c.x,c.y),a=this.detectBridgeNodes(i);for(const h of a)e.set(h.id,h);n.push({id:Lt(i.id),roadId:i.id,hierarchy:i.hierarchy,fromNodeId:l,toNodeId:d,fromVillageId:i.fromVillageId,toVillageId:i.toVillageId,length:this.roadLength(i),hasBridge:a.length>0,bridgeNodeIds:a.map(h=>h.id)})}return{roadNodes:Array.from(e.values()).sort((i,r)=>i.id.localeCompare(r.id)),roadEdges:n.sort((i,r)=>i.id.localeCompare(r.id))}}endpointNodeId(t,s,e,n,o,i,r){const c=s.get(o);if(c&&Math.hypot(c.x-i,c.y-r)<=8)return o;const l=Ft(e,n);return t.has(l)||t.set(l,{id:l,kind:"junction",x:i,y:r,roadId:e}),l}detectBridgeNodes(t){if(t.points.length<2)return[];const s=this.roadLength(t);if(s<=1)return[];const e=[];let n=0,o=-1;for(let c=1;c<t.points.length;c+=1){const l=t.points[c-1],d=t.points[c],a=Math.hypot(d.x-l.x,d.y-l.y);if(a<=1e-6)continue;const h=Math.max(2,Math.ceil(a/8));for(let f=0;f<=h;f+=1){const u=f/h,p=l.x+(d.x-l.x)*u,m=l.y+(d.y-l.y)*u,y=n+a*u,M=this.terrain.sample(p,m).waterDepth>.004;M&&o<0?o=y:!M&&o>=0&&(e.push({startDistance:o,endDistance:y}),o=-1)}n+=a}o>=0&&e.push({startDistance:o,endDistance:s});const i=[];let r=0;for(const c of e){const l=c.endDistance-c.startDistance,d=(c.startDistance+c.endDistance)*.5,a=c.startDistance/s,h=c.endDistance/s;if(l<4||l>140||a<.04||h>.96)continue;const f=this.pointAtDistance(t,d);i.push({id:Tt(t.id,r),kind:"bridge",x:f.x,y:f.y,roadId:t.id}),r+=1}return i}roadLength(t){let s=0;for(let e=1;e<t.points.length;e+=1){const n=t.points[e-1],o=t.points[e];s+=Math.hypot(o.x-n.x,o.y-n.y)}return s}pointAtDistance(t,s){if(t.points.length===0)return{x:0,y:0};if(t.points.length===1)return t.points[0];let e=Math.max(0,s);for(let n=1;n<t.points.length;n+=1){const o=t.points[n-1],i=t.points[n],r=Math.hypot(i.x-o.x,i.y-o.y);if(!(r<=1e-6)){if(e<=r){const c=e/r;return{x:o.x+(i.x-o.x)*c,y:o.y+(i.y-o.y)*c}}e-=r}}return t.points[t.points.length-1]}}class Wt{constructor(t,s,e){this.config=t,this.terrain=s,this.houseSeed=e}generateHouses(t){const s=[];for(const e of t){const n=this.houseSeed^B(e.id);if(!this.shouldPlaceHouse(e,n))continue;const o=e.width*x(.62,.9,R(I(n,2,3,79))),i=e.depth*x(.5,.84,R(I(n,3,2,83))),r=(e.depth-i)*.35,c=Math.cos(e.angle+Math.PI*.5),l=Math.sin(e.angle+Math.PI*.5),d=e.x-c*e.side*r,a=e.y-l*e.side*r,h=this.terrain.probe(d,a);if(h.waterDepth>.001||h.slope>this.config.houses.maxSlope)continue;const f=(R(I(n,5,1,89))*2-1)*.08,u=Math.floor(R(I(n,7,11,97))*4);s.push({id:It(e.id),x:d,y:a,width:o,depth:i,angle:e.angle+f,roofStyle:u})}return s}shouldPlaceHouse(t,s){const e=R(I(s,1,1,67)),n=t.roadHierarchy==="arterial"?.38:t.roadHierarchy==="collector"?.68:t.roadHierarchy==="lane"?.9:.72;return e<=n}}class Bt{constructor(t,s,e){this.config=t,this.terrain=s,this.parcelSeed=e}generateParcels(t,s){const e=[],n=new Map,o=new Map,i=11;for(const r of s)n.set(r.id,r),o.set(r.id,0);for(const r of t){const c=this.parcelSpacingMultiplier(r.hierarchy),l=this.config.houses.spacing*c;for(let d=1;d<r.points.length;d+=1){const a=r.points[d-1],h=r.points[d],f=h.x-a.x,u=h.y-a.y,p=Math.hypot(f,u);if(p<l*.65)continue;const m=f/p,y=u/p,M=-y,w=m,b=Math.floor(p/l);for(let C=1;C<b;C+=1){const v=C/b,$=x(a.x,h.x,v),k=x(a.y,h.y,v),S=this.pickVillageForRoadPosition(r,v,n);if(S&&this.shouldKeepForVillageDensity(r,$,k,S))for(const P of[-1,1]){const L=B(`${r.id}:${d}:${C}:${P}`);if(!this.shouldSpawnParcel(L,r.hierarchy))continue;const T=o.get(S.id)??0;if(T>=140)continue;const W=R(I(this.parcelSeed^L,d,C,43)),A=R(I(this.parcelSeed^L,d,C,47)),G=R(I(this.parcelSeed^L,d,C,53)),O=x(this.config.houses.minWidth*1.1,this.config.houses.maxWidth*1.5,W),E=x(this.config.houses.minDepth*1.5,this.config.houses.maxDepth*2,A),K=x(this.config.houses.minSetback,this.config.houses.maxSetback,G)+r.width*.5,X=$+M*P*(K+E*.5),j=k+w*P*(K+E*.5),Z=this.terrain.probe(X,j);Z.waterDepth>.002||Z.slope>this.config.houses.maxSlope||!e.every(U=>{const gt=U.x-X,pt=U.y-j;return Math.hypot(gt,pt)>=i})||(e.push({id:$t(r.id,d,C,P),villageId:S.id,roadId:r.id,roadType:r.type,roadHierarchy:r.hierarchy,x:X,y:j,width:O,depth:E,angle:Math.atan2(y,m),side:P}),o.set(S.id,T+1))}}}}return e}parcelSpacingMultiplier(t){return t==="arterial"?1.85:t==="collector"?1.35:t==="lane"?1:.9}shouldSpawnParcel(t,s){const e=R(I(this.parcelSeed^t,3,7,61)),n=s==="arterial"?this.config.houses.sideChance*.16:s==="collector"?this.config.houses.sideChance*.52:s==="lane"?this.config.houses.sideChance*.95:this.config.houses.sideChance*.66;return e<=n}shouldKeepForVillageDensity(t,s,e,n){if(t.hierarchy==="lane"||t.hierarchy==="path")return!0;const o=Math.hypot(s-n.x,e-n.y),i=t.hierarchy==="collector"?n.radius*2.8:n.radius*2.1;return o<=i}pickVillageForRoadPosition(t,s,e){const n=e.get(t.fromVillageId),o=e.get(t.toVillageId);return t.fromVillageId===t.toVillageId?n??null:s<.5?n??o??null:o??n??null}}class Vt{constructor(t){this.parent=new Array(t),this.rank=new Array(t);for(let s=0;s<t;s+=1)this.parent[s]=s,this.rank[s]=0}find(t){return this.parent[t]!==t&&(this.parent[t]=this.find(this.parent[t])),this.parent[t]}union(t,s){const e=this.find(t),n=this.find(s);return e===n?!1:(this.rank[e]<this.rank[n]?this.parent[e]=n:this.rank[e]>this.rank[n]?this.parent[n]=e:(this.parent[n]=e,this.rank[e]+=1),!0)}}class Ht{constructor(t,s,e){this.config=t,this.terrain=s,this.roadSeed=e}buildRegionalRoadNetwork(t){if(t.length<2)return[];const s=new Map;for(let a=0;a<t.length;a+=1)s.set(t[a].id,a);const e=new Map;for(let a=0;a<t.length;a+=1){const h=t[a],f=[];for(let p=0;p<t.length;p+=1){if(a===p)continue;const m=t[p],y=m.x-h.x,M=m.y-h.y,w=Math.hypot(y,M);w>this.config.roads.maxConnectionDistance||f.push({village:m,distance:w})}f.sort((p,m)=>p.distance-m.distance);const u=Math.min(this.config.roads.nearestNeighbors,f.length);for(let p=0;p<u;p+=1){const m=f[p].village,y=Rt(h.id,m.id);if(!e.has(y)){const M=f[p].distance,w=this.estimateConnectionCost(h,m,M);e.set(y,{a:h,b:m,id:y,weight:w,distance:M})}}}const n=Array.from(e.values()).sort((a,h)=>a.weight-h.weight),o=new Vt(t.length),i=new Map,r=[];for(const a of n){const h=s.get(a.a.id),f=s.get(a.b.id);h===void 0||f===void 0||(o.union(h,f)?i.set(a.id,a):r.push(a))}const c=Math.floor(t.length*.28);let l=0;for(const a of r){if(l>=c)break;const h=R(I(this.roadSeed,a.a.cellX+a.b.cellX,a.a.cellY+a.b.cellY,199)),f=this.config.roads.loopChance*D(1-a.distance/this.config.roads.maxConnectionDistance,.25,1);h<f&&(i.set(a.id,a),l+=1)}const d=[];for(const a of i.values()){const h=a.distance>this.config.roads.maxConnectionDistance*.55?"major":"minor",f=h==="major"?"arterial":"collector",u=h==="major"?this.config.roads.majorWidth:this.config.roads.minorWidth;d.push({id:Dt(a.id),type:h,hierarchy:f,width:u,points:this.routeRoad(a.a,a.b,a.id),fromVillageId:a.a.id,toVillageId:a.b.id})}return d}buildLocalRoadNetwork(t,s){const e=[],n=[...s];for(const o of t){const i=B(`${this.config.seed}:local-road:${o.id}`),r=this.templatePattern(o,i),c=this.estimateVillageAxis(o,s,i),l=Math.cos(c),d=Math.sin(c),a=-d,h=l,f=Math.max(7,o.radius*.2),u=[];let p=0;for(let w=0;w<r.trunkAxes.length;w+=1){const b=r.trunkAxes[w],C=b==="axis"?l:a,v=b==="axis"?d:h,$=-v,k=C,S=R(I(i,w,17,677)),L=(R(I(i,w,19,701))*2-1)*Math.min(10,o.radius*.12)*(w===0?.45:1),T=o.radius*x(r.trunkLengthMin,r.trunkLengthMax,S),W=this.createStreetLine(o.x,o.y,C,v,$,k,T,L,S);if(!this.isRoadLineValid(W)||!this.isRoadLineDistinct(W,n,f))continue;const A={id:it(o.id,p),type:"local",hierarchy:r.trunkHierarchy,width:this.config.roads.localWidth*(w===0?1.12:1.04),points:W,fromVillageId:o.id,toVillageId:o.id};e.push(A),n.push(A),u.push(A),p+=1}const m=this.nearestRegionalRoadsToVillage(o,s,r.connectorCount);for(const w of m){if(u.length===0)break;if(w.distance>o.radius*r.maxConnectorDistanceFactor)continue;const b=this.closestPointOnRoadSet(w.pointX,w.pointY,u);if(!b)continue;const C=R(I(i,p,23,733)),v=this.createConnectorLine(b.x,b.y,w.pointX,w.pointY,C);if(!this.isRoadLineValid(v)||!this.isRoadLineDistinct(v,n,Math.max(6,this.config.roads.localWidth*2.1))||this.hasBlockedIntersections(v,n,6.5))continue;const $={id:it(o.id,p),type:"local",hierarchy:r.connectorHierarchy,width:this.config.roads.localWidth*1.02,points:v,fromVillageId:o.id,toVillageId:o.id};e.push($),n.push($),p+=1}const y=Math.max(4,Math.round(o.radius*(o.template==="crossroad"?.18:o.template==="lakeside"?.14:.12)));let M=0;for(let w=0;w<u.length;w+=1){const b=u[w],C=this.polylineLength(b.points),v=Math.max(2,Math.floor(C/r.minBranchSpacing));for(let $=1;$<v&&!(M>=y);$+=1){const k=I(i,w*211+$,37,823);if(R(k)>r.branchChance)continue;const P=($+R(I(k,2,1,827))*.35)/v,L=this.samplePolyline(b.points,P),T=R(I(k,3,1,829))<.5?-1:1,W=R(I(k,5,1,839)),A=o.radius*x(r.branchLengthMin,r.branchLengthMax,W),G=this.createBranchLine(L.x,L.y,L.tangentX,L.tangentY,T,A,W);if(!this.isRoadLineValid(G)||!this.isRoadLineDistinct(G,n,Math.max(6,f*.85))||this.hasBlockedIntersections(G,n,6.5))continue;const O=G[G.length-1];if(this.pointNearRoads(O.x,O.y,n,Math.max(8,this.config.roads.localWidth*2.4)))continue;const E={id:Pt(o.id,w,$),type:"local",hierarchy:r.branchHierarchy,width:this.config.roads.localWidth*.9,points:G,fromVillageId:o.id,toVillageId:o.id};e.push(E),n.push(E),M+=1}}}return e}estimateVillageAxis(t,s,e){const n=this.nearestRegionalRoadsToVillage(t,s,1)[0];return n?Math.atan2(n.tangentY,n.tangentX):R(I(e,t.cellX,t.cellY,83))*Math.PI*2}nearestRegionalRoadsToVillage(t,s,e){const n=[];for(const o of s){let i=Number.POSITIVE_INFINITY,r=1,c=0,l=t.x,d=t.y;if(!(o.points.length<2)){for(let a=1;a<o.points.length;a+=1){const h=o.points[a-1],f=o.points[a],u=this.closestPointOnSegment(t.x,t.y,h.x,h.y,f.x,f.y);if(u.distance>=i)continue;i=u.distance,l=u.x,d=u.y;const p=f.x-h.x,m=f.y-h.y,y=Math.hypot(p,m);y>1e-6&&(r=p/y,c=m/y)}Number.isFinite(i)&&n.push({distance:i,tangentX:r,tangentY:c,pointX:l,pointY:d})}}return n.sort((o,i)=>o.distance-i.distance),n.slice(0,Math.max(1,e))}templatePattern(t,s){const e=t.radius>94;if(t.template==="lakeside")return{trunkAxes:["axis"],trunkLengthMin:1.5,trunkLengthMax:2.2,trunkHierarchy:"lane",connectorCount:2,connectorHierarchy:"lane",maxConnectorDistanceFactor:2.4,branchChance:e?.72:.62,branchLengthMin:.56,branchLengthMax:1.04,branchHierarchy:"path",minBranchSpacing:e?22:25};if(t.template==="crossroad"){const n=R(I(s,t.cellX,t.cellY,431)),o=e||n>.56;return{trunkAxes:["axis","perp"],trunkLengthMin:o?1.45:1.35,trunkLengthMax:o?2.15:1.95,trunkHierarchy:"lane",connectorCount:o?3:2,connectorHierarchy:"lane",maxConnectorDistanceFactor:2.35,branchChance:o?.78:.68,branchLengthMin:.6,branchLengthMax:1.12,branchHierarchy:"path",minBranchSpacing:o?20:24}}return{trunkAxes:["axis"],trunkLengthMin:1.4,trunkLengthMax:1.85,trunkHierarchy:"path",connectorCount:1,connectorHierarchy:"path",maxConnectorDistanceFactor:2.3,branchChance:e?.6:.52,branchLengthMin:.52,branchLengthMax:.9,branchHierarchy:"path",minBranchSpacing:e?24:27}}createStreetLine(t,s,e,n,o,i,r,c,l){const d=(l*2-1)*r*.12,a=t+o*c,h=s+i*c,f={x:a-e*r+o*d,y:h-n*r+i*d},u={x:a+e*r-o*d,y:h+n*r-i*d},p={x:a+o*d*.4,y:h+i*d*.4};return[f,p,u]}createConnectorLine(t,s,e,n,o){const i=e-t,r=n-s,c=Math.hypot(i,r);if(c<=1e-6)return[{x:t,y:s},{x:e,y:n}];const l=i/c,a=-(r/c),h=l,f=(o*2-1)*Math.min(18,c*.18);return[{x:t,y:s},{x:x(t,e,.5)+a*f,y:x(s,n,.5)+h*f},{x:e,y:n}]}closestPointOnSegment(t,s,e,n,o,i){const r=o-e,c=i-n,l=r*r+c*c;if(l<=1e-6){const f=t-e,u=s-n;return{x:e,y:n,distance:Math.hypot(f,u)}}const d=D(((t-e)*r+(s-n)*c)/l,0,1),a=e+r*d,h=n+c*d;return{x:a,y:h,distance:Math.hypot(t-a,s-h)}}isRoadLineDistinct(t,s,e){if(t.length<2)return!1;const n=t[0],o=t[t.length-1],i=o.x-n.x,r=o.y-n.y,c=Math.hypot(i,r);if(c<=1e-6)return!1;const l=t[Math.floor(t.length*.5)];for(const d of s)for(let a=1;a<d.points.length;a+=1){const h=d.points[a-1],f=d.points[a],u=f.x-h.x,p=f.y-h.y,m=Math.hypot(u,p);if(m<=1e-6||Math.abs((i*u+r*p)/(c*m))<.86)continue;if(this.closestPointOnSegment(l.x,l.y,h.x,h.y,f.x,f.y).distance<=e)return!1}return!0}closestPointOnRoadSet(t,s,e){let n=Number.POSITIVE_INFINITY,o=0,i=0;for(const r of e)if(!(r.points.length<2))for(let c=1;c<r.points.length;c+=1){const l=r.points[c-1],d=r.points[c],a=this.closestPointOnSegment(t,s,l.x,l.y,d.x,d.y);a.distance<n&&(n=a.distance,o=a.x,i=a.y)}return Number.isFinite(n)?{x:o,y:i,distance:n}:null}hasBlockedIntersections(t,s,e){if(t.length<2)return!0;const n=t[0],o=t[t.length-1];for(let i=1;i<t.length;i+=1){const r=t[i-1],c=t[i];for(const l of s)for(let d=1;d<l.points.length;d+=1){const a=l.points[d-1],h=l.points[d],f=this.segmentIntersection(r.x,r.y,c.x,c.y,a.x,a.y,h.x,h.y);if(!f)continue;const u=Math.hypot(f.x-n.x,f.y-n.y)<=e||Math.hypot(f.x-o.x,f.y-o.y)<=e,p=Math.hypot(f.x-a.x,f.y-a.y)<=e||Math.hypot(f.x-h.x,f.y-h.y)<=e;if(!(u||p))return!0}}return!1}segmentIntersection(t,s,e,n,o,i,r,c){const l=e-t,d=n-s,a=r-o,h=c-i,f=l*h-d*a;if(Math.abs(f)<=1e-6)return null;const u=o-t,p=i-s,m=(u*h-p*a)/f,y=(u*d-p*l)/f;return m<0||m>1||y<0||y>1?null:{x:t+l*m,y:s+d*m}}pointNearRoads(t,s,e,n){const o=n*n;for(const i of e)for(let r=1;r<i.points.length;r+=1){const c=i.points[r-1],l=i.points[r],d=this.closestPointOnSegment(t,s,c.x,c.y,l.x,l.y);if(d.distance*d.distance<=o)return!0}return!1}polylineLength(t){let s=0;for(let e=1;e<t.length;e+=1){const n=t[e-1],o=t[e];s+=Math.hypot(o.x-n.x,o.y-n.y)}return s}samplePolyline(t,s){if(t.length<2)return{x:t[0]?.x??0,y:t[0]?.y??0,tangentX:1,tangentY:0};const e=this.polylineLength(t);if(e<=1e-6)return{x:t[0].x,y:t[0].y,tangentX:1,tangentY:0};let n=D(s,0,1)*e;for(let d=1;d<t.length;d+=1){const a=t[d-1],h=t[d],f=h.x-a.x,u=h.y-a.y,p=Math.hypot(f,u);if(!(p<=1e-6)){if(n<=p){const m=n/p;return{x:x(a.x,h.x,m),y:x(a.y,h.y,m),tangentX:f/p,tangentY:u/p}}n-=p}}const o=t[t.length-1],i=t[t.length-2],r=o.x-i.x,c=o.y-i.y,l=Math.hypot(r,c)||1;return{x:o.x,y:o.y,tangentX:r/l,tangentY:c/l}}createBranchLine(t,s,e,n,o,i,r){const c=-n*o,l=e*o,d=(r*2-1)*.2;let a=c*(1-Math.abs(d)*.35)+e*d,h=l*(1-Math.abs(d)*.35)+n*d;const f=Math.hypot(a,h)||1;a/=f,h/=f;const u=-h,p=a,m=(r*2-1)*Math.min(14,i*.24);return[{x:t,y:s},{x:t+a*i*.56+u*m*.3,y:s+h*i*.56+p*m*.3},{x:t+a*i,y:s+h*i}]}estimateConnectionCost(t,s,e){const n=Math.max(3,Math.round(e/110));let o=0;for(let i=1;i<n;i+=1){const r=i/n,c=this.terrain.probe(x(t.x,s.x,r),x(t.y,s.y,r));c.waterDepth>0&&(o+=3+c.waterDepth*12),o+=c.slope*.75}return e*(1+o/n)}routeRoad(t,s,e){const n=s.x-t.x,o=s.y-t.y,i=Math.hypot(n,o),r=Math.max(3,Math.round(i/this.config.roads.routeStep)),c=i>0?n/i:1,d=-(i>0?o/i:0),a=c,h=[],f=B(`edge:${e}`);for(let p=0;p<=r;p+=1){const m=p/r,y=x(t.x,s.x,m),M=x(t.y,s.y,m),w=Math.sin(m*Math.PI),b=R(I(f,p,r,67))*2-1,C=this.config.roads.maxCurvatureOffset*w*(.35+i/this.config.roads.maxConnectionDistance*.65);h.push({x:y+d*C*b,y:M+a*C*b})}h[0]={x:t.x,y:t.y},h[h.length-1]={x:s.x,y:s.y},this.smoothLine(h,2);const u=this.findBridgeableWaterRun(h);for(let p=0;p<2;p+=1)for(let m=1;m<h.length-1;m+=1){if(u&&m>=u.start&&m<=u.end)continue;const y=this.terrain.sample(h[m].x,h[m].y);if(y.waterDepth<=.003)continue;const M=this.terrain.gradientAt(h[m].x,h[m].y,5),w=Math.hypot(M.x,M.y);if(w<1e-4)continue;const b=8+y.waterDepth*85;h[m].x+=M.x/w*b,h[m].y+=M.y/w*b}return h[0]={x:t.x,y:t.y},h[h.length-1]={x:s.x,y:s.y},h}findBridgeableWaterRun(t){let s=-1,e=-1,n=0,o=0;for(let r=1;r<t.length-1;r+=1){const c=this.terrain.sample(t[r].x,t[r].y).waterDepth;if(!(c<=.004)){if(o=Math.max(o,c),s<0){s=r,e=r,n=1;continue}if(r===e+1){e=r;continue}if(n+=1,n>1)return null;s=r,e=r}}return s<0||e<0||e-s>4||s<2||e>t.length-3||o>.05||Math.hypot(t[e].x-t[s].x,t[e].y-t[s].y)>120?null:{start:s,end:e}}smoothLine(t,s){for(let e=0;e<s;e+=1)for(let n=1;n<t.length-1;n+=1)t[n]={x:t[n-1].x*.25+t[n].x*.5+t[n+1].x*.25,y:t[n-1].y*.25+t[n].y*.5+t[n+1].y*.25}}isRoadLineValid(t){for(let s=1;s<t.length;s+=1)if(this.terrain.sample(t[s].x,t[s].y).waterDepth>.007)return!1;return!0}}class At{constructor(t,s,e){this.candidateCache=new Map,this.maxCachedCandidates=28e3,this.config=t,this.terrain=s,this.villageSeed=e}collectVillagesInBounds(t,s,e,n){const o=this.config.settlement.cellSize,i=Math.floor(t/o)-1,r=Math.floor(s/o)+1,c=Math.floor(e/o)-1,l=Math.floor(n/o)+1,d=[];for(let a=c;a<=l;a+=1)for(let h=i;h<=r;h+=1){const f=this.villageAtCell(h,a);f&&f.x>=t&&f.x<=s&&f.y>=e&&f.y<=n&&d.push(f)}return d}clear(){this.candidateCache.clear()}villageAtCell(t,s){const e=this.candidateAt(t,s);if(e.score<this.config.settlement.suitabilityThreshold)return null;const n=this.config.settlement.minVillageDistance,o=n*n,i=Math.max(1,Math.ceil(n/this.config.settlement.cellSize)+1);for(let d=s-i;d<=s+i;d+=1)for(let a=t-i;a<=t+i;a+=1){if(a===t&&d===s)continue;const h=this.candidateAt(a,d);if(h.score<this.config.settlement.suitabilityThreshold)continue;const f=h.x-e.x,u=h.y-e.y;if(!(f*f+u*u>o)&&(h.score>e.score||h.score===e.score&&h.tieBreaker>e.tieBreaker))return null}const r=R(I(this.villageSeed,t,s,223)),c=x(44,92,D(e.score*.65+r*.35,0,1)),l=this.selectVillageTemplate(e.score,e.coastDistance,t,s);return{id:e.id,x:e.x,y:e.y,score:e.score,radius:c,cellX:t,cellY:s,template:l}}candidateAt(t,s){const e=`${t},${s}`,n=this.candidateCache.get(e);if(n)return n;const o=this.config.settlement.cellSize,i=I(this.villageSeed,t,s,41),r=R(V(i^2654435769)),c=R(V(i^2135587861)),l=(t+r)*o,d=(s+c)*o,a=this.terrain.probe(l,d),h=R(V(i^2715316799)),f=this.estimateCoastDistance(l,d);let u=0;if(a.waterDepth<=.003){const m=1-N(.08,.62,a.slope),y=Math.abs(a.moisture-this.config.settlement.targetMoisture),M=1-D(y/.46,0,1),w=this.coastPreferenceFactor(f),b=N(.64,.92,a.forestDensity)*.24,C=N(.92,.99,a.shore)*.35,v=N(.78,.98,a.elevation)*.2,$=.7+R(V(i^1114599283))*.45;u=(m*.42+M*.23+w*.35)*$,u-=b+C+v,u=D(u,0,1)}const p={id:vt(t,s),cellX:t,cellY:s,x:l,y:d,score:u,tieBreaker:h,coastDistance:f};return this.candidateCache.set(e,p),this.pruneCandidateCache(),p}coastPreferenceFactor(t){const s=this.config.settlement.preferredCoastMin,e=this.config.settlement.preferredCoastMax,n=this.config.settlement.maxCoastSearch;return t<=s?D(t/s,0,1):t<=e?1:D(1-(t-e)/Math.max(1,n-e),0,1)}selectVillageTemplate(t,s,e,n){const o=this.config.settlement.preferredCoastMin*1.2;if(s<=o)return"lakeside";const i=R(I(this.villageSeed,e,n,947));return t>this.config.settlement.suitabilityThreshold+.16||i<.34?"crossroad":"linear"}estimateCoastDistance(t,s){const e=this.config.settlement.maxCoastSearch,n=10,o=22;let i=e;for(let r=0;r<n;r+=1){const c=Math.PI*2*r/n,l=Math.cos(c),d=Math.sin(c);for(let a=o;a<=e;a+=o)if(this.terrain.sample(t+l*a,s+d*a).waterDepth>0){a<i&&(i=a);break}}return i}pruneCandidateCache(){if(this.candidateCache.size<=this.maxCachedCandidates)return;const t=this.candidateCache.size-this.maxCachedCandidates,s=this.candidateCache.keys();for(let e=0;e<t;e+=1){const n=s.next();if(n.done)break;this.candidateCache.delete(n.value)}}}class dt{constructor(t,s){this.regionCache=new Map,this.maxCachedRegions=220,this.config=t;const e=B(`${t.seed}:villages`),n=B(`${t.seed}:roads`),o=B(`${t.seed}:parcels`),i=B(`${t.seed}:houses`);this.villageGenerator=new At(t,s,e),this.roadGenerator=new Ht(t,s,n),this.parcelGenerator=new Bt(t,s,o),this.houseGenerator=new Wt(t,s,i),this.layoutBuilder=new Nt(t,s,this.villageGenerator,this.roadGenerator,this.parcelGenerator,this.houseGenerator)}getFeaturesForBounds(t,s,e,n){const o=this.config.roads.regionSize,i=Math.floor(t/o)-1,r=Math.floor(s/o)+1,c=Math.floor(e/o)-1,l=Math.floor(n/o)+1,d=new Map,a=new Map,h=new Map,f=new Map;for(let u=c;u<=l;u+=1)for(let p=i;p<=r;p+=1){const m=this.getRegion(p,u);for(const y of m.villages)z(y.x,y.y,t,s,e,n)&&d.set(y.id,y);for(const y of m.roads)Ct(y,t,s,e,n)&&a.set(y.id,y);for(const y of m.parcels)z(y.x,y.y,t,s,e,n)&&h.set(y.id,y);for(const y of m.houses)z(y.x,y.y,t,s,e,n)&&f.set(y.id,y)}return{villages:Array.from(d.values()),roads:Array.from(a.values()),parcels:Array.from(h.values()),houses:Array.from(f.values())}}clear(){this.regionCache.clear(),this.villageGenerator.clear()}getRegion(t,s){const e=kt(t,s),n=this.regionCache.get(e);if(n)return n;const o=this.generateRegion(t,s);return this.regionCache.set(e,o),this.pruneRegionCache(),o}generateRegion(t,s){return this.layoutBuilder.buildRegionLayout(t,s)}pruneRegionCache(){if(this.regionCache.size<=this.maxCachedRegions)return;const t=this.regionCache.size-this.maxCachedRegions,s=this.regionCache.keys();for(let e=0;e<t;e+=1){const n=s.next();if(n.done)break;this.regionCache.delete(n.value)}}}const rt=g=>g*g*(3-2*g),et=(g,t,s)=>R(I(g,t,s)),qt=(g,t,s)=>{const e=Math.floor(t),n=Math.floor(s),o=e+1,i=n+1,r=rt(t-e),c=rt(s-n),l=et(g,e,n),d=et(g,o,n),a=et(g,e,i),h=et(g,o,i),f=x(l,d,r),u=x(a,h,r);return x(f,u,c)},Q=(g,t,s,e)=>{let n=1,o=1,i=0,r=0;for(let c=0;c<e.octaves;c+=1)i+=qt(g+c*1013,t*o,s*o)*n,r+=n,n*=e.persistence,o*=e.lacunarity;return r>0?i/r:0},Gt=g=>({elevation:B(`${g}:terrain:elevation`),continental:B(`${g}:terrain:continental`),warpX:B(`${g}:terrain:warpX`),warpY:B(`${g}:terrain:warpY`),moisture:B(`${g}:terrain:moisture`)}),Et=g=>({elevation:{octaves:g.terrain.elevationOctaves,persistence:g.terrain.elevationPersistence,lacunarity:g.terrain.elevationLacunarity},moisture:{octaves:g.terrain.moistureOctaves,persistence:g.terrain.moisturePersistence,lacunarity:g.terrain.moistureLacunarity}}),nt=g=>{const t=Gt(g.seed),s=Et(g),e=(d,a)=>{const h=(Q(t.warpX,d*g.terrain.warpFrequency,a*g.terrain.warpFrequency,{octaves:3,persistence:.54,lacunarity:2.15})*2-1)*g.terrain.warpAmplitude,f=(Q(t.warpY,(d+271.3)*g.terrain.warpFrequency,(a-194.8)*g.terrain.warpFrequency,{octaves:3,persistence:.54,lacunarity:2.15})*2-1)*g.terrain.warpAmplitude,u=d+h,p=a+f,m=Q(t.elevation,u*g.terrain.elevationFrequency,p*g.terrain.elevationFrequency,s.elevation),y=Q(t.continental,d*g.terrain.continentalFrequency,a*g.terrain.continentalFrequency,{octaves:4,persistence:.58,lacunarity:2}),M=D(m*.64+y*.36,0,1),w=M*M*(3-2*M);return D(w,0,1)},n=(d,a,h,f)=>{const u=Q(t.moisture,(d+5e3)*g.terrain.moistureFrequency,(a-2800)*g.terrain.moistureFrequency,s.moisture),p=f*.33,m=h>0?.19:0;return D(u*.72+p+m,0,1)},o=(d,a)=>{const h=e(d,a),f=g.terrain.seaLevel-h,u=1-D(Math.abs(f)/g.terrain.shoreBand,0,1),p=n(d,a,f,u);return{elevation:h,moisture:p,waterDepth:f,shore:u}},i=(d,a,h=3)=>{const f=(e(d+h,a)-e(d-h,a))/(2*h),u=(e(d,a+h)-e(d,a-h))/(2*h);return{x:f,y:u}},r=(d,a)=>{const h=i(d,a,5);return D(Math.hypot(h.x,h.y)*60,0,1)},c=(d,a)=>{const h=o(d,a);if(h.waterDepth>.012)return 0;const f=r(d,a),u=N(.28,.9,h.moisture),p=1-N(.22,.78,f),m=N(.6,.95,h.shore)*.3,y=N(.76,.98,h.elevation)*.35;return D(u*.73+p*.34-m-y,0,1)};return{sample:o,probe:(d,a)=>{const h=o(d,a),f=r(d,a),u=c(d,a);return{...h,slope:f,forestDensity:u}},gradientAt:i,slopeAt:r,forestDensityAt:c}},st=g=>{if(Array.isArray(g))return g.map(st);if(g&&typeof g=="object"){const t=Object.entries(g).sort(([e],[n])=>e.localeCompare(n)),s={};for(const[e,n]of t)s[e]=st(n);return s}return g},Ot=g=>({terrain:{...g.terrain},vegetation:{...g.vegetation},settlement:{...g.settlement},roads:{...g.roads},houses:{...g.houses}}),ut=g=>JSON.stringify(st(g)),Yt=g=>(B(g)>>>0).toString(16).padStart(8,"0"),zt=(g,t)=>Yt(ut({seed:g,generationConfig:t})),ft=g=>{const t=Ot(g);return{protocolVersion:1,seed:g.seed,generationConfig:t,configHash:zt(g.seed,t)}},Xt=g=>ut(g),J=g=>(B(g)>>>0).toString(16).padStart(8,"0"),F=(g,t=4)=>g.toFixed(t),jt=g=>{const t=nt(g),s=[];for(let e=-6;e<=6;e+=1)for(let n=-6;n<=6;n+=1){const o=n*73.25+e%3*11.7,i=e*68.5+n%4*9.3,r=t.probe(o,i);s.push(`${F(r.elevation)}|${F(r.moisture)}|${F(r.waterDepth)}|${F(r.slope)}|${F(r.forestDensity)}`)}return J(s.join(";"))},Kt=g=>{const t=nt(g),s=new lt(g,t).getRiversForBounds(-1900,1900,-1900,1900).slice();s.sort((n,o)=>{const i=n.points[0]?.x??0,r=n.points[0]?.y??0,c=o.points[0]?.x??0,l=o.points[0]?.y??0;return i===c?r-l:i-c});const e=s.map(n=>{const o=n.points.slice(0,14).map(i=>`${F(i.x,2)},${F(i.y,2)}`).join("|");return`${F(n.width,3)}:${o}`});return J(e.join(";"))},Ut=g=>{const t=nt(g),e=new dt(g,t).getFeaturesForBounds(-1850,1850,-1850,1850),n=e.villages.slice().sort((u,p)=>u.id.localeCompare(p.id)),o=e.roads.slice().sort((u,p)=>u.id.localeCompare(p.id)),i=e.parcels.slice().sort((u,p)=>u.id.localeCompare(p.id)),r=e.houses.slice().sort((u,p)=>u.id.localeCompare(p.id)),c=n.map(u=>`${u.id}:${u.template}:${F(u.x,2)},${F(u.y,2)},${F(u.score,4)},${F(u.radius,2)}`),l=o.map(u=>{const p=u.points[0],m=u.points[u.points.length-1];return`${u.id}:${u.type}:${u.hierarchy}:${F(u.width,2)}:${F(p?.x??0,2)},${F(p?.y??0,2)}>${F(m?.x??0,2)},${F(m?.y??0,2)}`}),d=i.map(u=>`${u.id}:${u.roadId}:${u.roadHierarchy}:${F(u.x,2)},${F(u.y,2)},${F(u.width,2)},${F(u.depth,2)},${F(u.angle,4)}`),a=r.map(u=>`${u.id}:${F(u.x,2)},${F(u.y,2)},${F(u.width,2)},${F(u.depth,2)},${F(u.angle,4)},${u.roofStyle}`),h=J([...c,...l,...d,...a].join(";")),f=J([...n.map(u=>u.id),...o.map(u=>u.id),...i.map(u=>u.id),...r.map(u=>u.id)].join("|"));return{coreHash:h,idHash:f}},Qt=g=>{const t=ft(g),s=jt(g),e=Kt(g),n=Ut(g),o=J([t.configHash,s,e,n.coreHash,n.idHash].join("/"));return{protocolVersion:t.protocolVersion,seed:g.seed,configHash:t.configHash,digests:{terrainHash:s,riversHash:e,settlementsHash:n.coreHash,stableIdHash:n.idHash,overallHash:o}}},_t=(g,t=3)=>{const s=[];for(let o=0;o<Math.max(1,t);o+=1)s.push(Qt(g));const e=s[0].digests.overallHash;return{consistent:s.every(o=>o.digests.overallHash===e),runs:s}};class Jt{constructor(t,s,e,n){this.config=t,this.terrain=s,this.debug=e,this.seedHash=n}sample(t,s,e){if(this.debug.showWaterMask)return e.waterDepth>.001?{r:84,g:144,b:212}:e.shore>.48?{r:188,g:210,b:175}:{r:159,g:191,b:145};if(this.debug.showMoisture){const P=D(e.moisture,0,1);if(P<.33){const T=P/.33;return{r:x(25,52,T),g:x(45,122,T),b:x(120,112,T)}}if(P<.66){const T=(P-.33)/.33;return{r:x(52,116,T),g:x(122,178,T),b:x(112,64,T)}}const L=(P-.66)/.34;return{r:x(116,222,L),g:x(178,201,L),b:x(64,78,L)}}if(this.debug.showForestMask){const P=this.terrain.forestDensityAt(t,s);return{r:x(18,95,P),g:x(27,198,P),b:x(22,74,P)}}const n=(R(I(this.seedHash,t,s,77))-.5)*7,o=N(.18,.87,e.elevation),i=N(.1,.92,e.moisture);let r=x(132,173,o)-i*17,c=x(167,196,o)-i*11,l=x(122,156,o)-i*18;this.debug.showContours&&this.config.terrain.contourInterval>0&&e.elevation/this.config.terrain.contourInterval%1<this.config.terrain.contourStrength&&(r-=18,c-=18,l-=18);const d=e.shore*.42;r=x(r,193,d),c=x(c,198,d),l=x(l,165,d),r+=n,c+=n,l+=n;const a=D(e.waterDepth/Math.max(this.config.terrain.shoreBand*1.8,.001),0,1),h=N(.22,1,a);let f=x(86,74,h),u=x(147,131,h),p=x(214,199,h);const m=n*.16;f+=m,u+=m,p+=m;const y=this.sampleWaterCoverage(t,s,e),M=D(y,0,1);let w=x(r,f,M),b=x(c,u,M),C=x(l,p,M);const v=1-Math.abs(y*2-1),$=1-N(.003,.02,e.waterDepth),k=N(.8,1,y),S=Math.max(v,N(.82,.99,e.shore)*$*k);return w=x(w,27,S*.44),b=x(b,52,S*.44),C=x(C,80,S*.44),{r:w,g:b,b:C}}sampleWaterCoverage(t,s,e){if(e.shore<.22)return e.waterDepth>0?1:0;let n=0;const o=[-.28,.28];for(let i=0;i<o.length;i+=1)for(let r=0;r<o.length;r+=1)this.terrain.sample(t+o[r],s+o[i]).waterDepth>0&&(n+=1);return n/4}}const _={sunDirection:{y:-.57},shadowOffset:{x:2.2,y:2.8},roofPalettes:[{wall:"#c3b59d",roofLight:"#a98b7a",roofDark:"#7f6357"},{wall:"#b7b8b0",roofLight:"#87919b",roofDark:"#646d76"},{wall:"#c2b19e",roofLight:"#a67963",roofDark:"#7f5848"},{wall:"#bbb09f",roofLight:"#958674",roofDark:"#6d6254"}]},at=12,q={field:{base:.21,ringWeight:.56,roadWeight:.24,moistureWeight:.14,forestPenaltyWeight:.5,shorePenaltyWeight:.15,slopePenaltyWeight:.31,roadStart:16},forest:{villagePenaltyWeight:.62,roadPenaltyWeight:.52,fieldPressureWeight:.58,shorePenaltyWeight:.24,moistureWeight:.05,roadStart:14}};class Zt{constructor(t,s,e){this.roadDistanceCache=new Map,this.villageDistanceCache=new Map,this.config=t,this.terrain=s,this.features=e}fieldSuitabilityForVillage(t,s,e){const n=this.terrain.probe(t,s);if(n.waterDepth>.001||n.slope>.36)return 0;const o=Math.hypot(t-e.x,s-e.y),i=e.radius*1.7,r=Math.max(e.radius*.85,1),c=D(1-Math.abs(o-i)/r,0,1),l=this.nearestRoadDistance(t,s),d=Math.max(this.config.settlement.minVillageDistance*.5,92),a=Number.isFinite(l)?1-N(q.field.roadStart,d,l):0,h=N(.55,.84,n.forestDensity),f=N(.6,.96,n.shore),u=N(.28,.76,n.moisture);return D(q.field.base+c*q.field.ringWeight+a*q.field.roadWeight+u*q.field.moistureWeight-h*q.field.forestPenaltyWeight-f*q.field.shorePenaltyWeight-n.slope*q.field.slopePenaltyWeight,0,1)}forestSuitability(t,s,e){if(e<=0)return 0;const n=this.terrain.probe(t,s);if(n.waterDepth>.012)return 0;const o=this.nearestVillageInfo(t,s),i=this.nearestRoadDistance(t,s),r=Math.max(this.config.settlement.minVillageDistance*.22,55),c=Math.max(this.config.settlement.minVillageDistance*1.05,r+80),l=Number.isFinite(o.distance)?1-N(r,c,o.distance):0,d=Math.max(this.config.settlement.minVillageDistance*.34,96),a=Number.isFinite(i)?1-N(q.forest.roadStart,d,i):0,h=N(.58,.97,n.shore)*q.forest.shorePenaltyWeight,f=this.fieldPressure(o,i),u=e*(1-l*q.forest.villagePenaltyWeight-a*q.forest.roadPenaltyWeight-f*q.forest.fieldPressureWeight)*(1-h)+n.moisture*q.forest.moistureWeight;return D(u,0,1)}fieldPressure(t,s){if(!Number.isFinite(t.distance)||t.radius<=0||!Number.isFinite(s))return 0;const e=t.radius*.96,n=t.radius*2.55;if(t.distance<e||t.distance>n)return 0;const o=(e+n)*.5,i=Math.max((n-e)*.5,1),r=D(1-Math.abs(t.distance-o)/i,0,1),c=1-N(22,Math.max(this.config.settlement.minVillageDistance*.44,140),s);return D(r*c,0,1)}nearestVillageInfo(t,s){const e=this.cacheKey(t,s),n=this.villageDistanceCache.get(e);if(n)return n;let o=Number.POSITIVE_INFINITY,i=0;for(const c of this.features.villages){const l=Math.hypot(t-c.x,s-c.y);l<o&&(o=l,i=c.radius)}const r={distance:o,radius:i};return this.villageDistanceCache.set(e,r),r}nearestRoadDistance(t,s){const e=this.cacheKey(t,s),n=this.roadDistanceCache.get(e);if(n!==void 0)return n;let o=Number.POSITIVE_INFINITY;for(const i of this.features.roads)for(let r=1;r<i.points.length;r+=1){const c=i.points[r-1],l=i.points[r],d=this.distanceToSegment(t,s,c.x,c.y,l.x,l.y)-i.width;d<o&&(o=d)}return this.roadDistanceCache.set(e,o),o}distanceToSegment(t,s,e,n,o,i){const r=o-e,c=i-n,l=r*r+c*c;if(l<=1e-6)return Math.hypot(t-e,s-n);const d=D(((t-e)*r+(s-n)*c)/l,0,1),a=e+r*d,h=n+c*d;return Math.hypot(t-a,s-h)}cacheKey(t,s){return`${Math.floor(t/at)},${Math.floor(s/at)}`}}const te=(g,t)=>`${g},${t}`;class ee{constructor(t,s){this.cache=new Map,this.config=t,this.settlements=s}getFeaturesForChunk(t,s){const e=Math.max(1,this.config.chunk.superchunkSpanChunks|0),n=Math.floor(t/e),o=Math.floor(s/e),i=te(n,o),r=this.cache.get(i);if(r)return r.features;const c=this.config.chunk.pixelSize,l=e*c,d=n*l,a=o*l,h=d+l,f=a+l,u=this.config.chunk.featureMargin,p=this.settlements.getFeaturesForBounds(d-u,h+u,a-u,f+u);return this.cache.set(i,{key:i,features:p}),this.prune(),p}clear(){this.cache.clear()}prune(){const t=this.config.chunk.maxCachedSuperchunks;if(this.cache.size<=t)return;const s=this.cache.size-t,e=this.cache.keys();for(let n=0;n<s;n+=1){const o=e.next();if(o.done)break;this.cache.delete(o.value)}}}class ne{constructor(t,s,e,n,o,i){this.config=t,this.terrain=s,this.debug=n,this.treeSeed=o,this.fieldSeed=i,this.superchunkCache=new ee(t,e)}draw(t,s,e,n,o,i,r){if(this.debug.showWaterMask||this.debug.showMoisture||this.debug.showForestMask)return;const l=this.superchunkCache.getFeaturesForChunk(s,e),d=new Zt(this.config,this.terrain,l);this.drawFields(t,n,o,i,l,d),this.drawRoadsAndVillages(t,n,o,l,r),this.drawParcels(t,n,o,l.parcels),this.drawHouses(t,n,o,l),this.drawForest(t,n,o,i,d)}drawForest(t,s,e,n,o){const i=this.config.vegetation.treeGridSize,r=this.config.vegetation.treeRenderMargin,c=H(s-r,i),l=H(s+n+r,i),d=H(e-r,i),a=H(e+n+r,i),h=this.config.vegetation.forestDenseThreshold,f=this.config.vegetation.forestMinDensity,u=[],p=[];for(let M=d;M<=a;M+=1)for(let w=c;w<=l;w+=1){const b=I(this.treeSeed,w,M),C=R(V(b^2779993889)),v=R(V(b^4046232899)),$=w*i+C*i,k=M*i+v*i,S=this.terrain.forestDensityAt($,k),P=o.forestSuitability($,k,S);if(P<f)continue;const L=D((P-f)/(1-f),0,1);if(R(V(b^1831565813))>L*L)continue;const W=R(V(b^2654435769)),A=x(this.config.vegetation.treeMinRadius,this.config.vegetation.treeMaxRadius,P)*(.8+W*.5),G=R(V(b^1327217884)),O=$-s,E=k-e;P>=h?u.push({gx:w,gy:M,x:O,y:E,radius:A,alpha:D(.32+P*.34,.2,.7),shape:G}):p.push({x:O,y:E,radius:A*.72,alpha:D(.42+P*.3,.25,.7),shape:G})}const m=this.groupDenseTrees(u),y=[...p];for(const M of m){if(M.length<5){for(const b of M)y.push({x:b.x,y:b.y,radius:b.radius*.88,alpha:D(b.alpha+.08,.35,.78),shape:b.shape});continue}this.drawDenseForestMass(t,M);const w=new Set(M.map(b=>`${b.gx},${b.gy}`));for(const b of M)this.isDenseBoundaryTree(b.gx,b.gy,w)&&y.push({x:b.x,y:b.y,radius:b.radius*.82,alpha:D(b.alpha+.14,.38,.84),shape:b.shape})}for(const M of y)this.drawTreeSymbol(t,M.x,M.y,M.radius,M.shape,`rgba(119, 161, 141, ${M.alpha.toFixed(3)})`)}drawFields(t,s,e,n,o,i){const d=n+44,a=n+44,h=18;for(const f of o.villages){const u=f.radius*1.08,p=f.radius*2.28;for(let m=0;m<h;m+=1){const y=I(this.fieldSeed,f.cellX*97+m*13,f.cellY*89+m*17),M=R(y)*Math.PI*2,w=x(u,p,R(V(y^2654435769))),b=x(-20,20,R(V(y^2135587861))),C=f.x+Math.cos(M)*w+Math.cos(M+Math.PI*.5)*b,v=f.y+Math.sin(M)*w+Math.sin(M+Math.PI*.5)*b,$=i.fieldSuitabilityForVillage(C,v,f);if($<.22||R(V(y^461845907))>$)continue;const S=x(26,68,R(V(y^3518319157))),P=x(16,40,R(V(y^2496678331))),L=Math.max(S,P)*.55+7;if(this.pointNearRoad(C,v,o.roads,L))continue;const T=C-s,W=v-e;if(T<-44||W<-44||T>d||W>a)continue;const A=R(V(y^2246822507)),G=R(V(y^3266489909)),O=M+x(-.6,.6,R(V(y^668265263))),E=Math.round(x(173,208,A)),K=Math.round(x(162,194,A)),X=Math.round(x(126,148,A));t.save(),t.translate(T,W),t.rotate(O),t.fillStyle=`rgba(${E}, ${K}, ${X}, 0.36)`,t.strokeStyle=`rgba(${Math.max(0,E-70)}, ${Math.max(0,K-62)}, ${Math.max(0,X-48)}, 0.56)`,t.lineWidth=1.3,t.fillRect(-S*.5,-P*.5,S,P),t.strokeRect(-S*.5,-P*.5,S,P);const j=Math.max(2,Math.floor(P/6)),Z=x(.22,.36,G);t.strokeStyle=`rgba(104, 84, 52, ${Z.toFixed(3)})`,t.lineWidth=1.1;for(let tt=1;tt<j;tt+=1){const U=-P*.5+P*tt/j;t.beginPath(),t.moveTo(-S*.45,U),t.lineTo(S*.45,U),t.stroke()}t.restore()}}}drawTreeSymbol(t,s,e,n,o,i){const r=Math.max(2.4,n),c=4+Math.floor(o*3),l=o*Math.PI*2,d=r*.58;t.fillStyle=i,t.beginPath();for(let a=0;a<c;a+=1){const h=l+a/c*Math.PI*2,f=r*(.84+(a+1)%2*.18),u=s+Math.cos(h)*f*.5,p=e+Math.sin(h)*f*.42;a===0?t.moveTo(u,p):t.lineTo(u,p)}t.closePath(),t.fill(),t.strokeStyle="rgba(14, 18, 16, 0.9)",t.lineWidth=1.4,t.stroke(),t.fillStyle="rgba(177, 205, 183, 0.34)",t.beginPath(),t.arc(s-r*.22,e-r*.18,d,0,Math.PI*2),t.fill()}groupDenseTrees(t){const s=new Map;for(const i of t)s.set(`${i.gx},${i.gy}`,i);const e=new Set,n=[],o=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];for(const i of t){const r=`${i.gx},${i.gy}`;if(e.has(r))continue;const c=[i];e.add(r);const l=[];for(;c.length>0;){const d=c.pop();if(!d)break;l.push(d);for(const a of o){const h=d.gx+a[0],f=d.gy+a[1],u=`${h},${f}`;if(e.has(u))continue;const p=s.get(u);p&&(e.add(u),c.push(p))}}n.push(l)}return n}isDenseBoundaryTree(t,s,e){for(let n=-1;n<=1;n+=1)for(let o=-1;o<=1;o+=1)if(!(o===0&&n===0)&&!e.has(`${t+o},${s+n}`))return!0;return!1}drawDenseForestMass(t,s){const e=s.map(a=>({x:a.x,y:a.y})),n=this.convexHull(e);if(n.length<3)return;let o=0,i=0;for(const a of n)o+=a.x,i+=a.y;o/=n.length,i/=n.length;const r=s.reduce((a,h)=>a+h.radius,0)/s.length,c=n.map(a=>{const h=a.x-o,f=a.y-i,u=Math.hypot(h,f);if(u<=1e-6)return a;const p=Math.max(6,r*.95);return{x:a.x+h/u*p,y:a.y+f/u*p}});t.fillStyle="rgba(84, 118, 103, 0.88)",t.strokeStyle="rgba(11, 14, 12, 0.84)",t.lineWidth=2,t.beginPath();for(let a=0;a<c.length;a+=1){const h=c[a],f=c[(a+1)%c.length],u=(h.x+f.x)*.5,p=(h.y+f.y)*.5;a===0?t.moveTo(u,p):t.quadraticCurveTo(h.x,h.y,u,p)}const l=c[0],d=c[1%c.length];t.quadraticCurveTo(l.x,l.y,(l.x+d.x)*.5,(l.y+d.y)*.5),t.closePath(),t.fill(),t.stroke()}convexHull(t){if(t.length<4)return t.slice();const s=t.slice().sort((o,i)=>o.x===i.x?o.y-i.y:o.x-i.x),e=[];for(const o of s){for(;e.length>=2&&this.cross2(e[e.length-2],e[e.length-1],o)<=0;)e.pop();e.push(o)}const n=[];for(let o=s.length-1;o>=0;o-=1){const i=s[o];for(;n.length>=2&&this.cross2(n[n.length-2],n[n.length-1],i)<=0;)n.pop();n.push(i)}return n.pop(),e.pop(),e.concat(n)}cross2(t,s,e){return(s.x-t.x)*(e.y-t.y)-(s.y-t.y)*(e.x-t.x)}pointNearRoad(t,s,e,n){const o=n*n;for(const i of e)for(let r=1;r<i.points.length;r+=1){const c=i.points[r-1],l=i.points[r],d=this.distanceSqToSegment(t,s,c.x,c.y,l.x,l.y),a=i.width+2;if(d<=o+a*a)return!0}return!1}distanceSqToSegment(t,s,e,n,o,i){const r=o-e,c=i-n,l=r*r+c*c;if(l<=1e-6){const p=t-e,m=s-n;return p*p+m*m}const d=D(((t-e)*r+(s-n)*c)/l,0,1),a=e+r*d,h=n+c*d,f=t-a,u=s-h;return f*f+u*u}drawRoadsAndVillages(t,s,e,n,o){if(!(!this.debug.showRoads&&!this.debug.showVillages)){if(this.debug.showRoads){const i=[];for(const r of n.roads)r.points.length<2||this.drawRoadSegments(t,r,s,e,o,i);i.length>0&&this.drawBridges(t,s,e,i)}this.debug.showVillages&&this.drawVillageMarkers(t,s,e,n.villages)}}drawRoadSegments(t,s,e,n,o,i){t.lineCap="round",t.lineJoin="round";for(let r=1;r<s.points.length;r+=1){const c=s.points[r-1],l=s.points[r],d=this.collectBridgeCuts(c.x,c.y,l.x,l.y,s.width,o,i);if(d.length===0){this.strokeRoadSegment(t,s,c.x,c.y,l.x,l.y,e,n);continue}let a=0;for(const h of d)h.startT>a+.03&&this.strokeRoadSegment(t,s,x(c.x,l.x,a),x(c.y,l.y,a),x(c.x,l.x,h.startT),x(c.y,l.y,h.startT),e,n),a=Math.max(a,h.endT);a<.97&&this.strokeRoadSegment(t,s,x(c.x,l.x,a),x(c.y,l.y,a),l.x,l.y,e,n)}}strokeRoadPath(t,s){const e=s.hierarchy==="arterial"?3.2:s.hierarchy==="collector"?2.7:s.hierarchy==="lane"?2.15:1.75,n=s.hierarchy==="arterial"?"rgba(226, 212, 171, 0.985)":s.hierarchy==="collector"?"rgba(213, 201, 164, 0.97)":s.hierarchy==="lane"?"rgba(204, 196, 167, 0.95)":"rgba(188, 182, 158, 0.94)";t.strokeStyle="rgba(8, 10, 11, 0.88)",t.lineWidth=s.width+e,t.stroke(),t.strokeStyle=n,t.lineWidth=s.hierarchy==="path"?s.width*.94:s.width,t.stroke()}strokeRoadSegment(t,s,e,n,o,i,r,c){t.beginPath(),t.moveTo(e-r,n-c),t.lineTo(o-r,i-c),this.strokeRoadPath(t,s)}collectBridgeCuts(t,s,e,n,o,i,r){const c=e-t,l=n-s,d=Math.hypot(c,l);if(d<=1e-6)return[];const a=[];for(const u of i)for(let p=1;p<u.points.length;p+=1){const m=u.points[p-1],y=u.points[p],M=this.segmentIntersection(t,s,e,n,m.x,m.y,y.x,y.y);if(!M)continue;const w=D(u.width*.9+o*1.55,6,26),b=D(M.t-w/d,0,1),C=D(M.t+w/d,0,1);a.push({startT:b,endT:C});const v={x1:x(t,e,b),y1:x(s,n,b),x2:x(t,e,C),y2:x(s,n,C),width:o};this.hasNearbyBridge(r,v)||r.push(v)}const h=this.sampleTerrainWaterCut(t,s,e,n);if(h){a.push(h);const u={x1:x(t,e,h.startT),y1:x(s,n,h.startT),x2:x(t,e,h.endT),y2:x(s,n,h.endT),width:o};this.hasNearbyBridge(r,u)||r.push(u)}if(a.length===0)return[];a.sort((u,p)=>u.startT-p.startT);const f=[a[0]];for(let u=1;u<a.length;u+=1){const p=a[u],m=f[f.length-1];p.startT<=m.endT+.03?m.endT=Math.max(m.endT,p.endT):f.push(p)}return f}sampleTerrainWaterCut(t,s,e,n){let r=-1,c=-1;for(let l=1;l<8;l+=1){const d=l/8,a=x(t,e,d),h=x(s,n,d);if(this.terrain.sample(a,h).waterDepth>.002)r<0&&(r=d),c=d;else if(r>=0)break}return r<0||c<0||c-r<.06?null:{startT:D(r-.08,0,1),endT:D(c+.08,0,1)}}segmentIntersection(t,s,e,n,o,i,r,c){const l=e-t,d=n-s,a=r-o,h=c-i,f=l*h-d*a;if(Math.abs(f)<=1e-6)return null;const u=o-t,p=i-s,m=(u*h-p*a)/f,y=(u*d-p*l)/f;return m<0||m>1||y<0||y>1?null:{t:m,x:t+l*m,y:s+d*m}}hasNearbyBridge(t,s){const e=(s.x1+s.x2)*.5,n=(s.y1+s.y2)*.5;for(const o of t){const i=(o.x1+o.x2)*.5,r=(o.y1+o.y2)*.5;if(Math.hypot(e-i,n-r)<5)return!0}return!1}drawBridges(t,s,e,n){for(const o of n){const i=o.x2-o.x1,r=o.y2-o.y1,c=Math.hypot(i,r);if(c<=1e-4)continue;const l=(o.x1+o.x2)*.5-s,d=(o.y1+o.y2)*.5-e,a=Math.atan2(r,i),h=o.width+1.4,f=h*.46;t.save(),t.translate(l,d),t.rotate(a),t.strokeStyle="rgba(10, 12, 12, 0.9)",t.lineWidth=h+2.4,t.lineCap="round",t.beginPath(),t.moveTo(-c*.5,0),t.lineTo(c*.5,0),t.stroke(),t.strokeStyle="rgba(216, 192, 152, 0.98)",t.lineWidth=h,t.beginPath(),t.moveTo(-c*.5,0),t.lineTo(c*.5,0),t.stroke(),t.strokeStyle="rgba(13, 14, 13, 0.8)",t.lineWidth=1,t.beginPath(),t.moveTo(-c*.48,-f),t.lineTo(c*.48,-f),t.moveTo(-c*.48,f),t.lineTo(c*.48,f),t.stroke(),t.strokeStyle="rgba(76, 57, 37, 0.46)";for(let u=-c*.5+2;u<c*.5-2;u+=4)t.beginPath(),t.moveTo(u,-h*.4),t.lineTo(u,h*.4),t.stroke();t.restore()}}drawVillageMarkers(t,s,e,n){for(const o of n){const i=o.x-s,r=o.y-e,c=D(o.radius*.07,3,6);t.fillStyle="rgba(244, 230, 186, 0.92)",t.beginPath(),t.arc(i,r,c,0,Math.PI*2),t.fill(),t.strokeStyle="rgba(10, 14, 12, 0.9)",t.lineWidth=1.4,t.stroke(),t.beginPath(),t.moveTo(i-c*1.4,r),t.lineTo(i+c*1.4,r),t.moveTo(i,r-c*1.4),t.lineTo(i,r+c*1.4),t.lineWidth=1,t.stroke()}}drawParcels(t,s,e,n){if(this.debug.showParcels)for(const o of n){const i=o.x-s,r=o.y-e;t.save(),t.translate(i,r),t.rotate(o.angle),t.fillStyle="rgba(211, 218, 167, 0.28)",t.strokeStyle="rgba(11, 15, 13, 0.82)",t.lineWidth=1.2,t.fillRect(-o.width*.5,-o.depth*.5,o.width,o.depth),t.strokeRect(-o.width*.5,-o.depth*.5,o.width,o.depth),t.restore()}}drawHouses(t,s,e,n){if(this.debug.showHouses)for(const o of n.houses)this.drawHouse(t,s,e,o)}drawHouse(t,s,e,n){const o=n.x-s,i=n.y-e,r=_.roofPalettes[n.roofStyle%_.roofPalettes.length];t.save(),t.translate(o,i),t.rotate(n.angle),t.fillStyle="rgba(25, 33, 38, 0.2)",t.fillRect(-n.width*.55+_.shadowOffset.x,-n.depth*.5+_.shadowOffset.y,n.width,n.depth),t.fillStyle=r.wall,t.strokeStyle="rgba(8, 10, 10, 0.9)",t.lineWidth=1.3,t.fillRect(-n.width*.5,-n.depth*.5,n.width,n.depth),t.strokeRect(-n.width*.5,-n.depth*.5,n.width,n.depth);const c=-n.width*.6,l=-n.depth*.52,d=n.width*1.2,a=n.depth*.58,h=l+a*.52,f=Math.cos(n.angle),m=.82*Math.sin(n.angle)+_.sunDirection.y*f<0;t.fillStyle=m?r.roofLight:r.roofDark,t.fillRect(c,l,d,h-l),t.fillStyle=m?r.roofDark:r.roofLight,t.fillRect(c,h,d,l+a-h),t.strokeStyle="rgba(8, 10, 10, 0.9)",t.strokeRect(c,l,d,a),t.strokeStyle="rgba(12, 10, 9, 0.66)",t.beginPath(),t.moveTo(c+1.4,h),t.lineTo(c+d-1.4,h),t.stroke(),t.restore()}}const Y=g=>Math.max(0,Math.min(255,Math.round(g)));class se{constructor(t,s,e){this.config=t,this.terrain=s,this.colorSampler=e}render(t,s,e,n,o,i){const r=this.buildRiverSegments(i);if(o===1){this.renderFullResolution(t,s,e,n,r);return}this.renderBlockSampled(t,s,e,n,o,r)}renderFullResolution(t,s,e,n,o){const i=t.createImageData(n,n),r=i.data;let c=0;for(let l=0;l<n;l+=1)for(let d=0;d<n;d+=1){const a=s+d,h=e+l,f=this.sampleUnifiedWater(a,h,o),u=this.colorSampler.sample(a,h,f);r[c]=Y(u.r),r[c+1]=Y(u.g),r[c+2]=Y(u.b),r[c+3]=255,c+=4}t.putImageData(i,0,0)}renderBlockSampled(t,s,e,n,o,i){const r=t.createImageData(n,n),c=r.data;for(let l=0;l<n;l+=o)for(let d=0;d<n;d+=o){const a=Math.min(o,n-d),h=Math.min(o,n-l),f=s+d+o*.5,u=e+l+o*.5,p=this.sampleUnifiedWater(f,u,i);if(p.shore>.14){for(let C=0;C<h;C+=1)for(let v=0;v<a;v+=1){const $=d+v,k=l+C,S=s+$+.5,P=e+k+.5,L=this.sampleUnifiedWater(S,P,i),T=this.colorSampler.sample(S,P,L),W=(k*n+$)*4;c[W]=Y(T.r),c[W+1]=Y(T.g),c[W+2]=Y(T.b),c[W+3]=255}continue}const y=this.colorSampler.sample(f,u,p),M=Y(y.r),w=Y(y.g),b=Y(y.b);for(let C=0;C<h;C+=1)for(let v=0;v<a;v+=1){const $=d+v,S=((l+C)*n+$)*4;c[S]=M,c[S+1]=w,c[S+2]=b,c[S+3]=255}}t.putImageData(r,0,0)}sampleUnifiedWater(t,s,e){const n=this.terrain.sample(t,s);if(e.length===0)return n;const o=1.4;let i=n.waterDepth,r=0;for(const l of e){if(t<l.minX-o||t>l.maxX+o||s<l.minY-o||s>l.maxY+o)continue;const d=this.distanceToSegment(t,s,l.ax,l.ay,l.bx,l.by);if(!(d>l.halfWidth+o)){if(d<=l.halfWidth){const a=1-D(d/Math.max(l.halfWidth,.001),0,1),h=Math.min(.048,this.config.terrain.shoreBand*.92),f=.003+a*h;f>i&&(i=f,r=Math.max(r,.16*a+.06))}else if(n.waterDepth<=.0015){const a=1-D((d-l.halfWidth)/o,0,1),h=a*.0018;h>i&&(i=h,r=Math.max(r,.05*a))}}}if(i<=n.waterDepth+1e-6)return n;const c=1-D(Math.abs(i)/this.config.terrain.shoreBand,0,1);return{elevation:n.elevation,moisture:D(n.moisture+r,0,1),waterDepth:i,shore:Math.max(n.shore,c)}}buildRiverSegments(t){const s=[];for(const e of t){if(e.points.length<2)continue;const n=Math.max(1.4,e.width*.5);for(let o=1;o<e.points.length;o+=1){const i=e.points[o-1],r=e.points[o];s.push({ax:i.x,ay:i.y,bx:r.x,by:r.y,halfWidth:n,minX:Math.min(i.x,r.x),maxX:Math.max(i.x,r.x),minY:Math.min(i.y,r.y),maxY:Math.max(i.y,r.y)})}}return s}distanceToSegment(t,s,e,n,o,i){const r=o-e,c=i-n,l=r*r+c*c;if(l<=1e-6)return Math.hypot(t-e,s-n);const d=D(((t-e)*r+(s-n)*c)/l,0,1),a=e+r*d,h=n+c*d;return Math.hypot(t-a,s-h)}}class oe{constructor(t,s,e,n,o,i,r,c){this.config=t,this.rivers=e,this.debug=o;const l=new Jt(t,s,o,i);this.terrainSurface=new se(t,s,l),this.overlays=new ne(t,s,n,o,r,c)}renderChunk(t,s){const e=this.config.chunk.pixelSize,n=Math.max(1,this.config.chunk.sampleStep|0),o=t*e,i=s*e,r=this.getRiversForChunk(o,i,e),c=document.createElement("canvas");c.width=e,c.height=e;const l=c.getContext("2d");if(!l)throw new Error("2D canvas context unavailable.");return this.terrainSurface.render(l,o,i,e,n,r),this.overlays.draw(l,t,s,o,i,e,r),c}getRiversForChunk(t,s,e){if(!this.debug.showRivers)return[];const n=48;return this.rivers.getRiversForBounds(t-n,t+e+n,s-n,s+e+n)}}class ie{constructor(t){this.warningCount=0,this.config=t}getWarningCount(){return this.warningCount}validate(t,s,e){if(!this.config.chunk.enableSeamValidation)return;const n=e(t,s);if(!n)return;const o=e(t-1,s);o&&this.compareVertical(o,n,t,s);const i=e(t,s-1);i&&this.compareHorizontal(i,n,t,s)}compareVertical(t,s,e,n){const o=this.config.chunk.seamColorTolerance,i=Math.min(t.width,s.width),r=Math.min(t.height,s.height);if(i<1||r<1)return;const c=t.getContext("2d"),l=s.getContext("2d");if(!c||!l)return;const d=c.getImageData(i-1,0,1,r).data,a=l.getImageData(0,0,1,r).data;let h=0;for(let u=0;u<d.length;u+=4)h+=Math.abs(d[u]-a[u]),h+=Math.abs(d[u+1]-a[u+1]),h+=Math.abs(d[u+2]-a[u+2]);const f=h/Math.max(1,r*3);f<=o||(this.warningCount+=1,this.warningCount<=14&&console.warn(`Seam mismatch (vertical) at chunk ${e-1},${n} -> ${e},${n}: avg RGB diff ${f.toFixed(2)}`))}compareHorizontal(t,s,e,n){const o=this.config.chunk.seamColorTolerance,i=Math.min(t.width,s.width),r=Math.min(t.height,s.height);if(i<1||r<1)return;const c=t.getContext("2d"),l=s.getContext("2d");if(!c||!l)return;const d=c.getImageData(0,r-1,i,1).data,a=l.getImageData(0,0,i,1).data;let h=0;for(let u=0;u<d.length;u+=4)h+=Math.abs(d[u]-a[u]),h+=Math.abs(d[u+1]-a[u+1]),h+=Math.abs(d[u+2]-a[u+2]);const f=h/Math.max(1,i*3);f<=o||(this.warningCount+=1,this.warningCount<=14&&console.warn(`Seam mismatch (horizontal) at chunk ${e},${n-1} -> ${e},${n}: avg RGB diff ${f.toFixed(2)}`))}}const ct=(g,t)=>`${g},${t}`,ht=()=>typeof performance<"u"?performance.now():Date.now();class re{constructor(t){this.chunkCache=new Map,this.pendingQueue=[],this.pendingSet=new Set,this.getReadyChunkCanvas=(r,c)=>{const l=this.chunkCache.get(ct(r,c));return!l||l.status!=="ready"?null:l.canvas},this.config=t,this.terrain=nt(t);const s=new lt(t,this.terrain),e=new dt(t,this.terrain),n=B(`${t.seed}:surface`),o=B(`${t.seed}:trees`),i=B(`${t.seed}:fields`);this.chunkRenderer=new oe(t,this.terrain,s,e,t.debug,n,o,i),this.seamValidator=new ie(t),this.placeholderCanvas=this.createPlaceholderChunkCanvas(t.chunk.pixelSize)}getSeed(){return this.config.seed}getChunkSize(){return this.config.chunk.pixelSize}sampleAt(t,s){return this.terrain.probe(t,s)}getWorldHandshake(){return ft(this.config)}getSerializedWorldHandshake(){return Xt(this.getWorldHandshake())}advanceGenerationBudget(){const t=Math.max(.2,this.config.chunk.generationBudgetMs),s=Math.max(1,this.config.chunk.maxChunkBuildsPerFrame|0),e=ht();let n=0;for(;n<s&&this.pendingQueue.length>0&&!(ht()-e>t);){const o=this.pendingQueue.shift();if(!o)break;this.pendingSet.delete(o);const i=this.chunkCache.get(o);!i||i.status==="ready"||(i.canvas=this.chunkRenderer.renderChunk(i.x,i.y),i.status="ready",n+=1,this.seamValidator.validate(i.x,i.y,this.getReadyChunkCanvas))}}getGenerationStats(){return{pendingChunks:this.pendingSet.size,seamWarnings:this.seamValidator.getWarningCount()}}getChunkCanvas(t,s){return this.getChunk(t,s,!0).canvas}prefetchChunksNearPlayer(t,s,e,n,o,i){const r=this.config.chunk.pixelSize,c=1;this.ensureChunkRange(H(t-e*.5,r)-c,H(t+e*.5,r)+c,H(s-n*.5,r)-c,H(s+n*.5,r)+c,!1);const l=Math.hypot(o,i);if(l<.12)return;const d=o/l,a=i/l,h=Math.max(0,this.config.chunk.prefetchLookaheadChunks|0),f=Math.max(0,this.config.chunk.prefetchLateralChunks|0);if(h===0&&f===0)return;const u=t+d*h*r,p=s+a*h*r,m=e*.5+f*r,y=n*.5+f*r;this.ensureChunkRange(H(u-m,r),H(u+m,r),H(p-y,r),H(p+y,r),!1)}getChunk(t,s,e){const n=ct(t,s),o=this.chunkCache.get(n);if(o&&e&&o.status==="pending"&&this.enqueueChunkGeneration(n,!0),o)return o;const i={x:t,y:s,canvas:this.placeholderCanvas,status:"pending"};return this.chunkCache.set(n,i),this.enqueueChunkGeneration(n,e),this.pruneCache(),i}enqueueChunkGeneration(t,s){if(this.pendingSet.has(t)){if(s){const e=this.pendingQueue.indexOf(t);e>0&&(this.pendingQueue.splice(e,1),this.pendingQueue.unshift(t))}return}this.pendingSet.add(t),s?this.pendingQueue.unshift(t):this.pendingQueue.push(t)}ensureChunkRange(t,s,e,n,o){for(let i=e;i<=n;i+=1)for(let r=t;r<=s;r+=1)this.getChunk(r,i,o)}pruneCache(){const t=this.config.chunk.maxCachedChunks;if(this.chunkCache.size<=t)return;const s=this.chunkCache.size-t,e=this.chunkCache.keys();for(let n=0;n<s;n+=1){const o=e.next();if(o.done)break;const i=o.value;this.chunkCache.delete(i),this.pendingSet.delete(i)}}createPlaceholderChunkCanvas(t){const s=document.createElement("canvas");s.width=t,s.height=t;const e=s.getContext("2d");if(!e)return s;e.fillStyle="#8fa486",e.fillRect(0,0,t,t),e.strokeStyle="rgba(65, 76, 60, 0.36)",e.lineWidth=1;const n=16;for(let o=-t;o<t*2;o+=n)e.beginPath(),e.moveTo(o,0),e.lineTo(o-t,t),e.stroke();return s}}const ae=()=>{const g=document.querySelector("#game"),t=document.querySelector("#hud");if(!g||!t)throw new Error("Missing #game canvas or #hud element.");const s=new URLSearchParams(window.location.search),e=s.get("seed")??"12345abcde",n=Number(s.get("chunkSize")??"320"),o=Number(s.get("seaLevel")??"NaN"),i=Number(s.get("sampleStep")??"2"),r=Number(s.get("superchunkSpan")??"NaN"),c=Number(s.get("genBudgetMs")??"NaN"),l=Number(s.get("maxChunkBuilds")??"NaN"),d=Number(s.get("prefetchLookahead")??"NaN"),a=Number(s.get("prefetchLateral")??"NaN"),h=s.get("seamValidation"),f=s.get("determinism"),u=Number(s.get("determinismRuns")??"3"),p=yt(e);Number.isFinite(n)&&n>=180&&n<=640&&(p.chunk.pixelSize=n),Number.isFinite(o)&&o>=.3&&o<=.68&&(p.terrain.seaLevel=o),Number.isFinite(i)&&i>=1&&i<=8&&(p.chunk.sampleStep=Math.floor(i)),Number.isFinite(r)&&r>=1&&r<=8&&(p.chunk.superchunkSpanChunks=Math.floor(r)),Number.isFinite(c)&&c>=.5&&c<=24&&(p.chunk.generationBudgetMs=c),Number.isFinite(l)&&l>=1&&l<=8&&(p.chunk.maxChunkBuildsPerFrame=Math.floor(l)),Number.isFinite(d)&&d>=0&&d<=8&&(p.chunk.prefetchLookaheadChunks=Math.floor(d)),Number.isFinite(a)&&a>=0&&a<=6&&(p.chunk.prefetchLateralChunks=Math.floor(a)),h==="0"||h==="false"?p.chunk.enableSeamValidation=!1:(h==="1"||h==="true")&&(p.chunk.enableSeamValidation=!0);const m=new re(p);if(f==="1"||f==="true"){const M=_t(p,Number.isFinite(u)?u:3);console.info("Determinism suite result",M)}new mt(g,t,m).start()};try{ae()}catch(g){const t=g instanceof Error?g.message:String(g);document.body.innerHTML=`<pre style="color:#fff;padding:16px">${t}</pre>`}
