(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))s(e);new MutationObserver(e=>{for(const o of e)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(e){const o={};return e.integrity&&(o.integrity=e.integrity),e.referrerPolicy&&(o.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?o.credentials="include":e.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(e){if(e.ep)return;e.ep=!0;const o=n(e);fetch(e.href,o)}})();const N=(f,t)=>Math.floor(f/t),C=(f,t,n)=>Math.max(t,Math.min(n,f)),b=(f,t,n)=>f+(t-f)*n,F=(f,t,n)=>{if(f===t)return n<f?0:1;const s=C((n-f)/(t-f),0,1);return s*s*(3-2*s)};class pt{constructor(t,n,s){this.input={up:!1,down:!1,left:!1,right:!1},this.playerX=0,this.playerY=0,this.lastTime=0,this.resize=()=>{this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight},this.onKeyDown=o=>{this.toggleDebugLayer(o)||((o.key==="w"||o.key==="ArrowUp")&&(this.input.up=!0),(o.key==="s"||o.key==="ArrowDown")&&(this.input.down=!0),(o.key==="a"||o.key==="ArrowLeft")&&(this.input.left=!0),(o.key==="d"||o.key==="ArrowRight")&&(this.input.right=!0))},this.onKeyUp=o=>{(o.key==="w"||o.key==="ArrowUp")&&(this.input.up=!1),(o.key==="s"||o.key==="ArrowDown")&&(this.input.down=!1),(o.key==="a"||o.key==="ArrowLeft")&&(this.input.left=!1),(o.key==="d"||o.key==="ArrowRight")&&(this.input.right=!1)},this.tick=o=>{const i=this.lastTime===0?0:Math.min(.05,(o-this.lastTime)/1e3);this.lastTime=o,this.update(i),this.render(),requestAnimationFrame(this.tick)},this.canvas=t,this.hud=n,this.world=s;const e=t.getContext("2d");if(!e)throw new Error("2D canvas context unavailable.");this.ctx=e,this.ctx.imageSmoothingEnabled=!1,window.addEventListener("resize",this.resize),window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp),this.resize()}start(){requestAnimationFrame(this.tick)}update(t){let n=0,s=0;if(this.input.left&&(n-=1),this.input.right&&(n+=1),this.input.up&&(s-=1),this.input.down&&(s+=1),n!==0||s!==0){const o=Math.hypot(n,s);n/=o,s/=o}const e=210;this.playerX+=n*e*t,this.playerY+=s*e*t,this.world.prefetchChunksNearPlayer(this.playerX,this.playerY,this.canvas.width,this.canvas.height,n,s),this.world.advanceGenerationBudget()}render(){const t=this.ctx,n=this.world.getChunkSize(),s=this.canvas.width*.5,e=this.canvas.height*.5,o=N(this.playerX-s,n)-1,i=N(this.playerX+s,n)+1,r=N(this.playerY-e,n)-1,c=N(this.playerY+e,n)+1;t.clearRect(0,0,this.canvas.width,this.canvas.height);for(let g=r;g<=c;g+=1)for(let u=o;u<=i;u+=1){const p=this.world.getChunkCanvas(u,g),m=Math.floor(u*n-this.playerX+s),y=Math.floor(g*n-this.playerY+e);t.drawImage(p,m,y,n,n)}const d=this.world.sampleAt(this.playerX,this.playerY),l=this.world.getDebugLayers(),a=this.world.getGenerationStats(),h=this.world.getWorldHandshake();t.fillStyle="#f4eec7",t.beginPath(),t.arc(s,e,6,0,Math.PI*2),t.fill(),t.strokeStyle="#1e252d",t.lineWidth=2,t.stroke(),this.hud.textContent=["Organic village generator (phase 0-7 systems implemented)","Move: WASD / Arrows","Debug: 1 water 2 moisture 3 forest 4 contours 5 rivers 6 roads 7 villages 8 houses 9 parcels","Mask modes (1/2/3) hide roads/parcels/houses/trees for readability",`Seed: ${this.world.getSeed()}`,`Handshake: v${h.protocolVersion} hash=${h.configHash}`,`Player px: ${this.playerX.toFixed(1)}, ${this.playerY.toFixed(1)}`,`Chunk: ${N(this.playerX,n)}, ${N(this.playerY,n)}`,`Elev: ${d.elevation.toFixed(3)} Moisture: ${d.moisture.toFixed(3)}`,`Slope: ${d.slope.toFixed(3)} Forest: ${d.forestDensity.toFixed(3)}`,`Water depth: ${d.waterDepth.toFixed(3)}`,`Streaming: pendingChunks=${a.pendingChunks} seamWarnings=${a.seamWarnings}`,`Layers: water=${l.showWaterMask?"on":"off"} moisture=${l.showMoisture?"on":"off"} forest=${l.showForestMask?"on":"off"} contours=${l.showContours?"on":"off"} rivers=${l.showRivers?"on":"off"} roads=${l.showRoads?"on":"off"} villages=${l.showVillages?"on":"off"} parcels=${l.showParcels?"on":"off"} houses=${l.showHouses?"on":"off"}`].join(`
`)}toggleDebugLayer(t){return t.repeat?!0:t.key==="1"?(this.world.toggleDebugLayer("showWaterMask"),!0):t.key==="2"?(this.world.toggleDebugLayer("showMoisture"),!0):t.key==="3"?(this.world.toggleDebugLayer("showForestMask"),!0):t.key==="4"?(this.world.toggleDebugLayer("showContours"),!0):t.key==="5"?(this.world.toggleDebugLayer("showRivers"),!0):t.key==="6"?(this.world.toggleDebugLayer("showRoads"),!0):t.key==="7"?(this.world.toggleDebugLayer("showVillages"),!0):t.key==="8"?(this.world.toggleDebugLayer("showHouses"),!0):t.key==="9"?(this.world.toggleDebugLayer("showParcels"),!0):!1}}const mt=f=>({seed:f,terrain:{elevationFrequency:.0018,elevationOctaves:5,elevationPersistence:.53,elevationLacunarity:2.1,continentalFrequency:34e-5,seaLevel:.49,shoreBand:.06,warpFrequency:.0012,warpAmplitude:120,moistureFrequency:.0017,moistureOctaves:4,moisturePersistence:.58,moistureLacunarity:2.05,contourInterval:.048,contourStrength:.18,riverRegionSize:1100,riverSeedsPerRegion:2,riverStartElevation:.6,riverStepLength:18,riverMaxSteps:110},vegetation:{treeGridSize:18,treeRenderMargin:24,forestMinDensity:.3,forestDenseThreshold:.58,treeMinRadius:3.2,treeMaxRadius:8.2},settlement:{cellSize:360,minVillageDistance:300,suitabilityThreshold:.47,targetMoisture:.5,maxCoastSearch:420,preferredCoastMin:90,preferredCoastMax:280},roads:{regionSize:1800,nearestNeighbors:3,maxConnectionDistance:900,loopChance:.12,majorWidth:3.2,minorWidth:2.2,localWidth:1.5,routeStep:80,maxCurvatureOffset:56},houses:{spacing:24,sideChance:.79,minSetback:9,maxSetback:16,minWidth:10,maxWidth:18,minDepth:8,maxDepth:14,maxSlope:.26},chunk:{pixelSize:320,maxCachedChunks:196,sampleStep:2,featureMargin:140,superchunkSpanChunks:3,maxCachedSuperchunks:80,generationBudgetMs:2.8,maxChunkBuildsPerFrame:1,prefetchLookaheadChunks:2,prefetchLateralChunks:1,enableSeamValidation:!1,seamColorTolerance:22},debug:{showContours:!1,showRivers:!0,showWaterMask:!1,showMoisture:!1,showForestMask:!1,showRoads:!0,showVillages:!1,showParcels:!1,showHouses:!0}}),yt=2166136261,wt=16777619,W=f=>{let t=yt;for(let n=0;n<f.length;n+=1)t^=f.charCodeAt(n),t=Math.imul(t,wt);return t>>>0},L=f=>{let t=f>>>0;return t^=t>>>16,t=Math.imul(t,2146121005),t^=t>>>15,t=Math.imul(t,2221713035),t^=t>>>16,t>>>0},P=(f,t,n,s=0)=>{const e=Math.imul(t|0,2654435761),o=Math.imul(n|0,2246822507),i=Math.imul(s|0,3266489909);return L((f^e^o^i)>>>0)},S=f=>(f>>>0)/4294967295,st=f=>{let t=f>>>0;return t===0&&(t=1),{next:()=>{t+=1831565813;let n=t;return n=Math.imul(n^n>>>15,n|1),n^=n+Math.imul(n^n>>>7,n|61),((n^n>>>14)>>>0)/4294967296}}},bt=(f,t)=>`${f},${t}`,Mt=(f,t,n,s,e)=>{for(const o of f)if(o.x>=t&&o.x<=n&&o.y>=s&&o.y<=e)return!0;return!1};class ht{constructor(t,n){this.regionCache=new Map,this.maxCachedRegions=512,this.config=t,this.terrain=n,this.regionSeed=W(`${t.seed}:rivers`)}getRiversForBounds(t,n,s,e){const o=this.config.terrain.riverRegionSize,i=Math.floor(t/o)-1,r=Math.floor(n/o)+1,c=Math.floor(s/o)-1,d=Math.floor(e/o)+1,l=[];for(let a=c;a<=d;a+=1)for(let h=i;h<=r;h+=1){const g=this.getRegion(h,a);for(const u of g)Mt(u.points,t,n,s,e)&&l.push(u)}return l}getRegion(t,n){const s=bt(t,n),e=this.regionCache.get(s);if(e)return e;const o=this.generateRegion(t,n);return this.regionCache.set(s,o),this.pruneCache(),o}generateRegion(t,n){const s=this.config.terrain.riverRegionSize,e=t*s,o=n*s,i=P(this.regionSeed,t,n),r=st(i),c=[];for(let d=0;d<this.config.terrain.riverSeedsPerRegion;d+=1){let l=null,a=-1;for(let g=0;g<12;g+=1){const u=e+r.next()*s,p=o+r.next()*s,m=this.terrain.sample(u,p);if(m.waterDepth>-.015)continue;const y=m.elevation-m.shore*.25;y>a&&(a=y,l={x:u,y:p})}if(!l||a<this.config.terrain.riverStartElevation)continue;const h=this.traceRiver(l.x,l.y,st(P(i,d,91)));if(h.length>10){const g=this.config.roads.majorWidth*(2.2+r.next()*.8);c.push({points:h,width:g})}}return c}traceRiver(t,n,s){const e=this.config.terrain.riverStepLength,o=this.config.terrain.riverMaxSteps,i=[{x:t,y:n}];let r=t,c=n,d=Math.cos(s.next()*Math.PI*2),l=Math.sin(s.next()*Math.PI*2),a=!1,h=this.terrain.sample(r,c).elevation;for(let g=0;g<o;g+=1){const u=this.terrain.gradientAt(r,c,5);let p=-u.x,m=-u.y;const y=Math.hypot(p,m);if(y<1e-5){const M=s.next()*Math.PI*2;p=Math.cos(M),m=Math.sin(M)}else p/=y,m/=y;p=d*.52+p*.48,m=l*.52+m*.48;const w=Math.hypot(p,m);w>0&&(p/=w,m/=w),d=p,l=m,r+=p*e,c+=m*e;const x=this.terrain.sample(r,c);if(x.elevation>h+.012)break;if(h=x.elevation,i.push({x:r,y:c}),x.waterDepth>.002&&g>8){a=!0;break}if(i.length>18){const M=i[i.length-12],k=r-M.x,R=c-M.y;if(k*k+R*R<e*e*2.5)return[]}if(i.length>10)for(let M=0;M<i.length-6;M+=1){const k=r-i[M].x,R=c-i[M].y;if(k*k+R*R<e*e*.65)return[]}}return a?i.reverse():[]}clear(){this.regionCache.clear()}pruneCache(){if(this.regionCache.size<=this.maxCachedRegions)return;const t=this.regionCache.size-this.maxCachedRegions,n=this.regionCache.keys();for(let s=0;s<t;s+=1){const e=n.next();if(e.done)break;this.regionCache.delete(e.value)}}}const xt=(f,t)=>`${f},${t}`,G=(f,t,n,s,e,o)=>f>=n&&f<=s&&t>=e&&t<=o,kt=(f,t,n,s,e)=>{for(const o of f.points)if(G(o.x,o.y,t,n,s,e))return!0;return!1},Ct=f=>{let t=0;for(let s=1;s<f.points.length;s+=1){const e=f.points[s].x-f.points[s-1].x,o=f.points[s].y-f.points[s-1].y;t+=Math.hypot(e,o)}if(t<1)return f.points[0];let n=t*.5;for(let s=1;s<f.points.length;s+=1){const e=f.points[s-1],o=f.points[s],i=Math.hypot(o.x-e.x,o.y-e.y);if(n<=i){const r=n/i;return{x:b(e.x,o.x,r),y:b(e.y,o.y,r)}}n-=i}return f.points[f.points.length-1]},St=(f,t)=>`v-${f},${t}`,vt=(f,t)=>f<t?`${f}|${t}`:`${t}|${f}`,Rt=f=>`r-${f}`,ot=(f,t)=>`rl-${f}-${t}`,Dt=(f,t,n)=>`rlb-${f}-${t}-${n}`,$t=(f,t,n,s)=>`p-${f}-${t}-${n}-${s}`,Pt=f=>`h-${f}`;class Ft{constructor(t,n,s){this.config=t,this.terrain=n,this.houseSeed=s}generateHouses(t){const n=[];for(const s of t){const e=this.houseSeed^W(s.id);if(!this.shouldPlaceHouse(s,e))continue;const o=s.width*b(.62,.9,S(P(e,2,3,79))),i=s.depth*b(.5,.84,S(P(e,3,2,83))),r=(s.depth-i)*.35,c=Math.cos(s.angle+Math.PI*.5),d=Math.sin(s.angle+Math.PI*.5),l=s.x-c*s.side*r,a=s.y-d*s.side*r,h=this.terrain.probe(l,a);if(h.waterDepth>.001||h.slope>this.config.houses.maxSlope)continue;const g=(S(P(e,5,1,89))*2-1)*.08,u=Math.floor(S(P(e,7,11,97))*4);n.push({id:Pt(s.id),x:l,y:a,width:o,depth:i,angle:s.angle+g,roofStyle:u})}return n}shouldPlaceHouse(t,n){const s=S(P(n,1,1,67)),e=t.roadType==="major"?.46:t.roadType==="minor"?.72:.88;return s<=e}}class Tt{constructor(t,n,s){this.config=t,this.terrain=n,this.parcelSeed=s}generateParcels(t,n){const s=[],e=new Map,o=new Map,i=11;for(const r of n)e.set(r.id,r),o.set(r.id,0);for(const r of t){const c=r.type==="major"?1.6:r.type==="minor"?1.25:1,d=this.config.houses.spacing*c;for(let l=1;l<r.points.length;l+=1){const a=r.points[l-1],h=r.points[l],g=h.x-a.x,u=h.y-a.y,p=Math.hypot(g,u);if(p<d*.65)continue;const m=g/p,y=u/p,w=-y,x=m,M=Math.floor(p/d);for(let k=1;k<M;k+=1){const R=k/M,I=b(a.x,h.x,R),H=b(a.y,h.y,R),D=this.pickVillageForRoadPosition(r,R,e);if(D&&this.shouldKeepForVillageDensity(r,I,H,D))for(const v of[-1,1]){const V=W(`${r.id}:${l}:${k}:${v}`);if(!this.shouldSpawnParcel(V,r.type))continue;const T=o.get(D.id)??0;if(T>=140)continue;const A=S(P(this.parcelSeed^V,l,k,43)),z=S(P(this.parcelSeed^V,l,k,47)),E=S(P(this.parcelSeed^V,l,k,53)),j=b(this.config.houses.minWidth*1.1,this.config.houses.maxWidth*1.5,A),q=b(this.config.houses.minDepth*1.5,this.config.houses.maxDepth*2,z),X=b(this.config.houses.minSetback,this.config.houses.maxSetback,E)+r.width*.5,Y=I+w*v*(X+q*.5),K=H+x*v*(X+q*.5),_=this.terrain.probe(Y,K);_.waterDepth>.002||_.slope>this.config.houses.maxSlope||!s.every(U=>{const ft=U.x-Y,gt=U.y-K;return Math.hypot(ft,gt)>=i})||(s.push({id:$t(r.id,l,k,v),villageId:D.id,roadId:r.id,roadType:r.type,x:Y,y:K,width:j,depth:q,angle:Math.atan2(y,m),side:v}),o.set(D.id,T+1))}}}}return s}shouldSpawnParcel(t,n){const s=S(P(this.parcelSeed^t,3,7,61)),e=n==="major"?this.config.houses.sideChance*.25:n==="minor"?this.config.houses.sideChance*.58:this.config.houses.sideChance*.95;return s<=e}shouldKeepForVillageDensity(t,n,s,e){if(t.type==="local")return!0;const o=Math.hypot(n-e.x,s-e.y),i=t.type==="minor"?e.radius*2.8:e.radius*2.1;return o<=i}pickVillageForRoadPosition(t,n,s){const e=s.get(t.fromVillageId),o=s.get(t.toVillageId);return t.fromVillageId===t.toVillageId?e??null:n<.5?e??o??null:o??e??null}}class Wt{constructor(t){this.parent=new Array(t),this.rank=new Array(t);for(let n=0;n<t;n+=1)this.parent[n]=n,this.rank[n]=0}find(t){return this.parent[t]!==t&&(this.parent[t]=this.find(this.parent[t])),this.parent[t]}union(t,n){const s=this.find(t),e=this.find(n);return s===e?!1:(this.rank[s]<this.rank[e]?this.parent[s]=e:this.rank[s]>this.rank[e]?this.parent[e]=s:(this.parent[e]=s,this.rank[s]+=1),!0)}}class It{constructor(t,n,s){this.config=t,this.terrain=n,this.roadSeed=s}buildRegionalRoadNetwork(t){if(t.length<2)return[];const n=new Map;for(let a=0;a<t.length;a+=1)n.set(t[a].id,a);const s=new Map;for(let a=0;a<t.length;a+=1){const h=t[a],g=[];for(let p=0;p<t.length;p+=1){if(a===p)continue;const m=t[p],y=m.x-h.x,w=m.y-h.y,x=Math.hypot(y,w);x>this.config.roads.maxConnectionDistance||g.push({village:m,distance:x})}g.sort((p,m)=>p.distance-m.distance);const u=Math.min(this.config.roads.nearestNeighbors,g.length);for(let p=0;p<u;p+=1){const m=g[p].village,y=vt(h.id,m.id);if(!s.has(y)){const w=g[p].distance,x=this.estimateConnectionCost(h,m,w);s.set(y,{a:h,b:m,id:y,weight:x,distance:w})}}}const e=Array.from(s.values()).sort((a,h)=>a.weight-h.weight),o=new Wt(t.length),i=new Map,r=[];for(const a of e){const h=n.get(a.a.id),g=n.get(a.b.id);h===void 0||g===void 0||(o.union(h,g)?i.set(a.id,a):r.push(a))}const c=Math.floor(t.length*.28);let d=0;for(const a of r){if(d>=c)break;const h=S(P(this.roadSeed,a.a.cellX+a.b.cellX,a.a.cellY+a.b.cellY,199)),g=this.config.roads.loopChance*C(1-a.distance/this.config.roads.maxConnectionDistance,.25,1);h<g&&(i.set(a.id,a),d+=1)}const l=[];for(const a of i.values()){const h=a.distance>this.config.roads.maxConnectionDistance*.55?"major":"minor",g=h==="major"?this.config.roads.majorWidth:this.config.roads.minorWidth;l.push({id:Rt(a.id),type:h,width:g,points:this.routeRoad(a.a,a.b,a.id),fromVillageId:a.a.id,toVillageId:a.b.id})}return l}buildLocalRoadNetwork(t,n){const s=[],e=[...n];for(const o of t){const i=W(`${this.config.seed}:local-road:${o.id}`),r=this.estimateVillageAxis(o,n,i),c=Math.cos(r),d=Math.sin(r),l=-d,a=c,h=C(o.radius*.5,24,44),g=Math.max(7,h*.34),u=this.nearestRegionalRoadToVillage(o,n);if(u&&u.distance<o.radius*1.8){const w=this.createConnectorLine(o.x,o.y,u.pointX,u.pointY,S(P(i,991,0,911)));if(this.isRoadLineValid(w)&&this.isRoadLineDistinct(w,e,Math.max(6,this.config.roads.localWidth*2.5))){const x={id:ot(o.id,0),type:"local",width:this.config.roads.localWidth,points:w,fromVillageId:o.id,toVillageId:o.id};s.push(x),e.push(x)}}const p=o.radius>102?[-1.15,-.45,.45,1.15]:o.radius>78?[-.85,0,.85]:[-.45,.45];let m=1;for(const w of p){const x=S(P(i,w+7,0,433)),M=this.createStreetLine(o.x,o.y,c,d,l,a,o.radius*b(1.35,1.95,x),w*h,x);if(!this.isRoadLineValid(M)||!this.isRoadLineDistinct(M,e,g))continue;const k={id:ot(o.id,m),type:"local",width:this.config.roads.localWidth,points:M,fromVillageId:o.id,toVillageId:o.id};s.push(k),e.push(k),m+=1}const y=o.radius>104?[-.85,-.35,.35,.85]:o.radius>80?[-.55,0,.55]:[-.32,.32];for(let w=0;w<y.length;w+=1){const x=S(P(i,w,0,541));if(y.length>3&&x<.14)continue;const M=this.createStreetLine(o.x,o.y,l,a,c,d,o.radius*b(.95,1.45,x),y[w]*h*1.2,x);if(!this.isRoadLineValid(M)||!this.isRoadLineDistinct(M,e,g))continue;const k={id:Dt(o.id,w,0),type:"local",width:this.config.roads.localWidth*.92,points:M,fromVillageId:o.id,toVillageId:o.id};s.push(k),e.push(k)}}return s}estimateVillageAxis(t,n,s){const e=this.nearestRegionalRoadToVillage(t,n);return e?Math.atan2(e.tangentY,e.tangentX):S(P(s,t.cellX,t.cellY,83))*Math.PI*2}nearestRegionalRoadToVillage(t,n){let s=Number.POSITIVE_INFINITY,e=1,o=0,i=t.x,r=t.y;for(const c of n)if(!(c.points.length<2))for(let d=1;d<c.points.length;d+=1){const l=c.points[d-1],a=c.points[d],h=this.closestPointOnSegment(t.x,t.y,l.x,l.y,a.x,a.y);if(h.distance>=s)continue;s=h.distance,i=h.x,r=h.y;const g=a.x-l.x,u=a.y-l.y,p=Math.hypot(g,u);p>1e-6&&(e=g/p,o=u/p)}return Number.isFinite(s)?{distance:s,tangentX:e,tangentY:o,pointX:i,pointY:r}:null}createStreetLine(t,n,s,e,o,i,r,c,d){const l=(d*2-1)*r*.12,a=t+o*c,h=n+i*c,g={x:a-s*r+o*l,y:h-e*r+i*l},u={x:a+s*r-o*l,y:h+e*r-i*l},p={x:a+o*l*.4,y:h+i*l*.4};return[g,p,u]}createConnectorLine(t,n,s,e,o){const i=s-t,r=e-n,c=Math.hypot(i,r);if(c<=1e-6)return[{x:t,y:n},{x:s,y:e}];const d=i/c,a=-(r/c),h=d,g=(o*2-1)*Math.min(18,c*.18);return[{x:t,y:n},{x:b(t,s,.5)+a*g,y:b(n,e,.5)+h*g},{x:s,y:e}]}closestPointOnSegment(t,n,s,e,o,i){const r=o-s,c=i-e,d=r*r+c*c;if(d<=1e-6){const g=t-s,u=n-e;return{x:s,y:e,distance:Math.hypot(g,u)}}const l=C(((t-s)*r+(n-e)*c)/d,0,1),a=s+r*l,h=e+c*l;return{x:a,y:h,distance:Math.hypot(t-a,n-h)}}isRoadLineDistinct(t,n,s){if(t.length<2)return!1;const e=t[0],o=t[t.length-1],i=o.x-e.x,r=o.y-e.y,c=Math.hypot(i,r);if(c<=1e-6)return!1;const d=t[Math.floor(t.length*.5)];for(const l of n)for(let a=1;a<l.points.length;a+=1){const h=l.points[a-1],g=l.points[a],u=g.x-h.x,p=g.y-h.y,m=Math.hypot(u,p);if(m<=1e-6||Math.abs((i*u+r*p)/(c*m))<.86)continue;if(this.closestPointOnSegment(d.x,d.y,h.x,h.y,g.x,g.y).distance<=s)return!1}return!0}estimateConnectionCost(t,n,s){const e=Math.max(3,Math.round(s/110));let o=0;for(let i=1;i<e;i+=1){const r=i/e,c=this.terrain.probe(b(t.x,n.x,r),b(t.y,n.y,r));c.waterDepth>0&&(o+=3+c.waterDepth*12),o+=c.slope*.75}return s*(1+o/e)}routeRoad(t,n,s){const e=n.x-t.x,o=n.y-t.y,i=Math.hypot(e,o),r=Math.max(3,Math.round(i/this.config.roads.routeStep)),c=i>0?e/i:1,l=-(i>0?o/i:0),a=c,h=[],g=W(`edge:${s}`);for(let p=0;p<=r;p+=1){const m=p/r,y=b(t.x,n.x,m),w=b(t.y,n.y,m),x=Math.sin(m*Math.PI),M=S(P(g,p,r,67))*2-1,k=this.config.roads.maxCurvatureOffset*x*(.35+i/this.config.roads.maxConnectionDistance*.65);h.push({x:y+l*k*M,y:w+a*k*M})}h[0]={x:t.x,y:t.y},h[h.length-1]={x:n.x,y:n.y},this.smoothLine(h,2);const u=this.findBridgeableWaterRun(h);for(let p=0;p<2;p+=1)for(let m=1;m<h.length-1;m+=1){if(u&&m>=u.start&&m<=u.end)continue;const y=this.terrain.sample(h[m].x,h[m].y);if(y.waterDepth<=.003)continue;const w=this.terrain.gradientAt(h[m].x,h[m].y,5),x=Math.hypot(w.x,w.y);if(x<1e-4)continue;const M=8+y.waterDepth*85;h[m].x+=w.x/x*M,h[m].y+=w.y/x*M}return h[0]={x:t.x,y:t.y},h[h.length-1]={x:n.x,y:n.y},h}findBridgeableWaterRun(t){let n=-1,s=-1,e=0,o=0;for(let r=1;r<t.length-1;r+=1){const c=this.terrain.sample(t[r].x,t[r].y).waterDepth;if(!(c<=.004)){if(o=Math.max(o,c),n<0){n=r,s=r,e=1;continue}if(r===s+1){s=r;continue}if(e+=1,e>1)return null;n=r,s=r}}return n<0||s<0||s-n>4||n<2||s>t.length-3||o>.05||Math.hypot(t[s].x-t[n].x,t[s].y-t[n].y)>120?null:{start:n,end:s}}smoothLine(t,n){for(let s=0;s<n;s+=1)for(let e=1;e<t.length-1;e+=1)t[e]={x:t[e-1].x*.25+t[e].x*.5+t[e+1].x*.25,y:t[e-1].y*.25+t[e].y*.5+t[e+1].y*.25}}isRoadLineValid(t){for(let n=1;n<t.length;n+=1)if(this.terrain.sample(t[n].x,t[n].y).waterDepth>.007)return!1;return!0}}class Lt{constructor(t,n,s){this.candidateCache=new Map,this.maxCachedCandidates=28e3,this.config=t,this.terrain=n,this.villageSeed=s}collectVillagesInBounds(t,n,s,e){const o=this.config.settlement.cellSize,i=Math.floor(t/o)-1,r=Math.floor(n/o)+1,c=Math.floor(s/o)-1,d=Math.floor(e/o)+1,l=[];for(let a=c;a<=d;a+=1)for(let h=i;h<=r;h+=1){const g=this.villageAtCell(h,a);g&&g.x>=t&&g.x<=n&&g.y>=s&&g.y<=e&&l.push(g)}return l}clear(){this.candidateCache.clear()}villageAtCell(t,n){const s=this.candidateAt(t,n);if(s.score<this.config.settlement.suitabilityThreshold)return null;const e=this.config.settlement.minVillageDistance,o=e*e,i=Math.max(1,Math.ceil(e/this.config.settlement.cellSize)+1);for(let d=n-i;d<=n+i;d+=1)for(let l=t-i;l<=t+i;l+=1){if(l===t&&d===n)continue;const a=this.candidateAt(l,d);if(a.score<this.config.settlement.suitabilityThreshold)continue;const h=a.x-s.x,g=a.y-s.y;if(!(h*h+g*g>o)&&(a.score>s.score||a.score===s.score&&a.tieBreaker>s.tieBreaker))return null}const r=S(P(this.villageSeed,t,n,223)),c=b(44,92,C(s.score*.65+r*.35,0,1));return{id:s.id,x:s.x,y:s.y,score:s.score,radius:c,cellX:t,cellY:n}}candidateAt(t,n){const s=`${t},${n}`,e=this.candidateCache.get(s);if(e)return e;const o=this.config.settlement.cellSize,i=P(this.villageSeed,t,n,41),r=S(L(i^2654435769)),c=S(L(i^2135587861)),d=(t+r)*o,l=(n+c)*o,a=this.terrain.probe(d,l),h=S(L(i^2715316799));let g=0;if(a.waterDepth<=.003){const p=this.estimateCoastDistance(d,l),m=1-F(.08,.62,a.slope),y=Math.abs(a.moisture-this.config.settlement.targetMoisture),w=1-C(y/.46,0,1),x=this.coastPreferenceFactor(p),M=F(.64,.92,a.forestDensity)*.24,k=F(.92,.99,a.shore)*.35,R=F(.78,.98,a.elevation)*.2,I=.7+S(L(i^1114599283))*.45;g=(m*.42+w*.23+x*.35)*I,g-=M+k+R,g=C(g,0,1)}const u={id:St(t,n),cellX:t,cellY:n,x:d,y:l,score:g,tieBreaker:h};return this.candidateCache.set(s,u),this.pruneCandidateCache(),u}coastPreferenceFactor(t){const n=this.config.settlement.preferredCoastMin,s=this.config.settlement.preferredCoastMax,e=this.config.settlement.maxCoastSearch;return t<=n?C(t/n,0,1):t<=s?1:C(1-(t-s)/Math.max(1,e-s),0,1)}estimateCoastDistance(t,n){const s=this.config.settlement.maxCoastSearch,e=10,o=22;let i=s;for(let r=0;r<e;r+=1){const c=Math.PI*2*r/e,d=Math.cos(c),l=Math.sin(c);for(let a=o;a<=s;a+=o)if(this.terrain.sample(t+d*a,n+l*a).waterDepth>0){a<i&&(i=a);break}}return i}pruneCandidateCache(){if(this.candidateCache.size<=this.maxCachedCandidates)return;const t=this.candidateCache.size-this.maxCachedCandidates,n=this.candidateCache.keys();for(let s=0;s<t;s+=1){const e=n.next();if(e.done)break;this.candidateCache.delete(e.value)}}}class lt{constructor(t,n){this.regionCache=new Map,this.maxCachedRegions=220,this.config=t;const s=W(`${t.seed}:villages`),e=W(`${t.seed}:roads`),o=W(`${t.seed}:parcels`),i=W(`${t.seed}:houses`);this.villageGenerator=new Lt(t,n,s),this.roadGenerator=new It(t,n,e),this.parcelGenerator=new Tt(t,n,o),this.houseGenerator=new Ft(t,n,i)}getFeaturesForBounds(t,n,s,e){const o=this.config.roads.regionSize,i=Math.floor(t/o)-1,r=Math.floor(n/o)+1,c=Math.floor(s/o)-1,d=Math.floor(e/o)+1,l=new Map,a=new Map,h=new Map,g=new Map;for(let u=c;u<=d;u+=1)for(let p=i;p<=r;p+=1){const m=this.getRegion(p,u);for(const y of m.villages)G(y.x,y.y,t,n,s,e)&&l.set(y.id,y);for(const y of m.roads)kt(y,t,n,s,e)&&a.set(y.id,y);for(const y of m.parcels)G(y.x,y.y,t,n,s,e)&&h.set(y.id,y);for(const y of m.houses)G(y.x,y.y,t,n,s,e)&&g.set(y.id,y)}return{villages:Array.from(l.values()),roads:Array.from(a.values()),parcels:Array.from(h.values()),houses:Array.from(g.values())}}clear(){this.regionCache.clear(),this.villageGenerator.clear()}getRegion(t,n){const s=xt(t,n),e=this.regionCache.get(s);if(e)return e;const o=this.generateRegion(t,n);return this.regionCache.set(s,o),this.pruneRegionCache(),o}generateRegion(t,n){const s=this.config.roads.regionSize,e=t*s,o=n*s,i=e+s,r=o+s,c=this.config.roads.maxConnectionDistance+this.config.settlement.cellSize,d=this.villageGenerator.collectVillagesInBounds(e-c,i+c,o-c,r+c),l=this.roadGenerator.buildRegionalRoadNetwork(d),a=this.roadGenerator.buildLocalRoadNetwork(d,l),h=[...l,...a],g=this.parcelGenerator.generateParcels(h,d),u=this.houseGenerator.generateHouses(g),p=d.filter(x=>G(x.x,x.y,e,i,o,r)),m=h.filter(x=>{const M=Ct(x);return G(M.x,M.y,e,i,o,r)}),y=g.filter(x=>G(x.x,x.y,e,i,o,r)),w=u.filter(x=>G(x.x,x.y,e,i,o,r));return{villages:p,roads:m,parcels:y,houses:w}}pruneRegionCache(){if(this.regionCache.size<=this.maxCachedRegions)return;const t=this.regionCache.size-this.maxCachedRegions,n=this.regionCache.keys();for(let s=0;s<t;s+=1){const e=n.next();if(e.done)break;this.regionCache.delete(e.value)}}}const it=f=>f*f*(3-2*f),tt=(f,t,n)=>S(P(f,t,n)),Nt=(f,t,n)=>{const s=Math.floor(t),e=Math.floor(n),o=s+1,i=e+1,r=it(t-s),c=it(n-e),d=tt(f,s,e),l=tt(f,o,e),a=tt(f,s,i),h=tt(f,o,i),g=b(d,l,r),u=b(a,h,r);return b(g,u,c)},Q=(f,t,n,s)=>{let e=1,o=1,i=0,r=0;for(let c=0;c<s.octaves;c+=1)i+=Nt(f+c*1013,t*o,n*o)*e,r+=e,e*=s.persistence,o*=s.lacunarity;return r>0?i/r:0},Vt=f=>({elevation:W(`${f}:terrain:elevation`),continental:W(`${f}:terrain:continental`),warpX:W(`${f}:terrain:warpX`),warpY:W(`${f}:terrain:warpY`),moisture:W(`${f}:terrain:moisture`)}),Bt=f=>({elevation:{octaves:f.terrain.elevationOctaves,persistence:f.terrain.elevationPersistence,lacunarity:f.terrain.elevationLacunarity},moisture:{octaves:f.terrain.moistureOctaves,persistence:f.terrain.moisturePersistence,lacunarity:f.terrain.moistureLacunarity}}),et=f=>{const t=Vt(f.seed),n=Bt(f),s=(l,a)=>{const h=(Q(t.warpX,l*f.terrain.warpFrequency,a*f.terrain.warpFrequency,{octaves:3,persistence:.54,lacunarity:2.15})*2-1)*f.terrain.warpAmplitude,g=(Q(t.warpY,(l+271.3)*f.terrain.warpFrequency,(a-194.8)*f.terrain.warpFrequency,{octaves:3,persistence:.54,lacunarity:2.15})*2-1)*f.terrain.warpAmplitude,u=l+h,p=a+g,m=Q(t.elevation,u*f.terrain.elevationFrequency,p*f.terrain.elevationFrequency,n.elevation),y=Q(t.continental,l*f.terrain.continentalFrequency,a*f.terrain.continentalFrequency,{octaves:4,persistence:.58,lacunarity:2}),w=C(m*.64+y*.36,0,1),x=w*w*(3-2*w);return C(x,0,1)},e=(l,a,h,g)=>{const u=Q(t.moisture,(l+5e3)*f.terrain.moistureFrequency,(a-2800)*f.terrain.moistureFrequency,n.moisture),p=g*.33,m=h>0?.19:0;return C(u*.72+p+m,0,1)},o=(l,a)=>{const h=s(l,a),g=f.terrain.seaLevel-h,u=1-C(Math.abs(g)/f.terrain.shoreBand,0,1),p=e(l,a,g,u);return{elevation:h,moisture:p,waterDepth:g,shore:u}},i=(l,a,h=3)=>{const g=(s(l+h,a)-s(l-h,a))/(2*h),u=(s(l,a+h)-s(l,a-h))/(2*h);return{x:g,y:u}},r=(l,a)=>{const h=i(l,a,5);return C(Math.hypot(h.x,h.y)*60,0,1)},c=(l,a)=>{const h=o(l,a);if(h.waterDepth>.012)return 0;const g=r(l,a),u=F(.28,.9,h.moisture),p=1-F(.22,.78,g),m=F(.6,.95,h.shore)*.3,y=F(.76,.98,h.elevation)*.35;return C(u*.73+p*.34-m-y,0,1)};return{sample:o,probe:(l,a)=>{const h=o(l,a),g=r(l,a),u=c(l,a);return{...h,slope:g,forestDensity:u}},gradientAt:i,slopeAt:r,forestDensityAt:c}},nt=f=>{if(Array.isArray(f))return f.map(nt);if(f&&typeof f=="object"){const t=Object.entries(f).sort(([s],[e])=>s.localeCompare(e)),n={};for(const[s,e]of t)n[s]=nt(e);return n}return f},Ht=f=>({terrain:{...f.terrain},vegetation:{...f.vegetation},settlement:{...f.settlement},roads:{...f.roads},houses:{...f.houses}}),dt=f=>JSON.stringify(nt(f)),At=f=>(W(f)>>>0).toString(16).padStart(8,"0"),qt=(f,t)=>At(dt({seed:f,generationConfig:t})),ut=f=>{const t=Ht(f);return{protocolVersion:1,seed:f.seed,generationConfig:t,configHash:qt(f.seed,t)}},Ot=f=>dt(f),J=f=>(W(f)>>>0).toString(16).padStart(8,"0"),$=(f,t=4)=>f.toFixed(t),zt=f=>{const t=et(f),n=[];for(let s=-6;s<=6;s+=1)for(let e=-6;e<=6;e+=1){const o=e*73.25+s%3*11.7,i=s*68.5+e%4*9.3,r=t.probe(o,i);n.push(`${$(r.elevation)}|${$(r.moisture)}|${$(r.waterDepth)}|${$(r.slope)}|${$(r.forestDensity)}`)}return J(n.join(";"))},Gt=f=>{const t=et(f),n=new ht(f,t).getRiversForBounds(-1900,1900,-1900,1900).slice();n.sort((e,o)=>{var l,a,h,g;const i=((l=e.points[0])==null?void 0:l.x)??0,r=((a=e.points[0])==null?void 0:a.y)??0,c=((h=o.points[0])==null?void 0:h.x)??0,d=((g=o.points[0])==null?void 0:g.y)??0;return i===c?r-d:i-c});const s=n.map(e=>{const o=e.points.slice(0,14).map(i=>`${$(i.x,2)},${$(i.y,2)}`).join("|");return`${$(e.width,3)}:${o}`});return J(s.join(";"))},Et=f=>{const t=et(f),s=new lt(f,t).getFeaturesForBounds(-1850,1850,-1850,1850),e=s.villages.slice().sort((u,p)=>u.id.localeCompare(p.id)),o=s.roads.slice().sort((u,p)=>u.id.localeCompare(p.id)),i=s.parcels.slice().sort((u,p)=>u.id.localeCompare(p.id)),r=s.houses.slice().sort((u,p)=>u.id.localeCompare(p.id)),c=e.map(u=>`${u.id}:${$(u.x,2)},${$(u.y,2)},${$(u.score,4)},${$(u.radius,2)}`),d=o.map(u=>{const p=u.points[0],m=u.points[u.points.length-1];return`${u.id}:${u.type}:${$(u.width,2)}:${$((p==null?void 0:p.x)??0,2)},${$((p==null?void 0:p.y)??0,2)}>${$((m==null?void 0:m.x)??0,2)},${$((m==null?void 0:m.y)??0,2)}`}),l=i.map(u=>`${u.id}:${u.roadId}:${$(u.x,2)},${$(u.y,2)},${$(u.width,2)},${$(u.depth,2)},${$(u.angle,4)}`),a=r.map(u=>`${u.id}:${$(u.x,2)},${$(u.y,2)},${$(u.width,2)},${$(u.depth,2)},${$(u.angle,4)},${u.roofStyle}`),h=J([...c,...d,...l,...a].join(";")),g=J([...e.map(u=>u.id),...o.map(u=>u.id),...i.map(u=>u.id),...r.map(u=>u.id)].join("|"));return{coreHash:h,idHash:g}},jt=f=>{const t=ut(f),n=zt(f),s=Gt(f),e=Et(f),o=J([t.configHash,n,s,e.coreHash,e.idHash].join("/"));return{protocolVersion:t.protocolVersion,seed:f.seed,configHash:t.configHash,digests:{terrainHash:n,riversHash:s,settlementsHash:e.coreHash,stableIdHash:e.idHash,overallHash:o}}},Yt=(f,t=3)=>{const n=[];for(let o=0;o<Math.max(1,t);o+=1)n.push(jt(f));const s=n[0].digests.overallHash;return{consistent:n.every(o=>o.digests.overallHash===s),runs:n}};class Kt{constructor(t,n,s,e){this.config=t,this.terrain=n,this.debug=s,this.seedHash=e}sample(t,n,s){if(this.debug.showWaterMask)return s.waterDepth>.001?{r:84,g:144,b:212}:s.shore>.48?{r:188,g:210,b:175}:{r:159,g:191,b:145};if(this.debug.showMoisture){const v=C(s.moisture,0,1);if(v<.33){const T=v/.33;return{r:b(25,52,T),g:b(45,122,T),b:b(120,112,T)}}if(v<.66){const T=(v-.33)/.33;return{r:b(52,116,T),g:b(122,178,T),b:b(112,64,T)}}const V=(v-.66)/.34;return{r:b(116,222,V),g:b(178,201,V),b:b(64,78,V)}}if(this.debug.showForestMask){const v=this.terrain.forestDensityAt(t,n);return{r:b(18,95,v),g:b(27,198,v),b:b(22,74,v)}}const e=(S(P(this.seedHash,t,n,77))-.5)*7,o=F(.18,.87,s.elevation),i=F(.1,.92,s.moisture);let r=b(132,173,o)-i*17,c=b(167,196,o)-i*11,d=b(122,156,o)-i*18;this.debug.showContours&&this.config.terrain.contourInterval>0&&s.elevation/this.config.terrain.contourInterval%1<this.config.terrain.contourStrength&&(r-=18,c-=18,d-=18);const l=s.shore*.42;r=b(r,193,l),c=b(c,198,l),d=b(d,165,l),r+=e,c+=e,d+=e;const a=C(s.waterDepth/Math.max(this.config.terrain.shoreBand*1.8,.001),0,1),h=F(.22,1,a);let g=b(86,74,h),u=b(147,131,h),p=b(214,199,h);const m=e*.16;g+=m,u+=m,p+=m;const y=this.sampleWaterCoverage(t,n,s),w=C(y,0,1);let x=b(r,g,w),M=b(c,u,w),k=b(d,p,w);const R=1-Math.abs(y*2-1),I=1-F(.003,.02,s.waterDepth),H=F(.8,1,y),D=Math.max(R,F(.82,.99,s.shore)*I*H);return x=b(x,27,D*.44),M=b(M,52,D*.44),k=b(k,80,D*.44),{r:x,g:M,b:k}}sampleWaterCoverage(t,n,s){if(s.shore<.22)return s.waterDepth>0?1:0;let e=0;const o=[-.28,.28];for(let i=0;i<o.length;i+=1)for(let r=0;r<o.length;r+=1)this.terrain.sample(t+o[r],n+o[i]).waterDepth>0&&(e+=1);return e/4}}const rt=12,B={field:{base:.21,ringWeight:.56,roadWeight:.24,moistureWeight:.14,forestPenaltyWeight:.5,shorePenaltyWeight:.15,slopePenaltyWeight:.31,roadStart:16},forest:{villagePenaltyWeight:.62,roadPenaltyWeight:.52,fieldPressureWeight:.58,shorePenaltyWeight:.24,moistureWeight:.05,roadStart:14}};class Xt{constructor(t,n,s){this.roadDistanceCache=new Map,this.villageDistanceCache=new Map,this.config=t,this.terrain=n,this.features=s}fieldSuitabilityForVillage(t,n,s){const e=this.terrain.probe(t,n);if(e.waterDepth>.001||e.slope>.36)return 0;const o=Math.hypot(t-s.x,n-s.y),i=s.radius*1.7,r=Math.max(s.radius*.85,1),c=C(1-Math.abs(o-i)/r,0,1),d=this.nearestRoadDistance(t,n),l=Math.max(this.config.settlement.minVillageDistance*.5,92),a=Number.isFinite(d)?1-F(B.field.roadStart,l,d):0,h=F(.55,.84,e.forestDensity),g=F(.6,.96,e.shore),u=F(.28,.76,e.moisture);return C(B.field.base+c*B.field.ringWeight+a*B.field.roadWeight+u*B.field.moistureWeight-h*B.field.forestPenaltyWeight-g*B.field.shorePenaltyWeight-e.slope*B.field.slopePenaltyWeight,0,1)}forestSuitability(t,n,s){if(s<=0)return 0;const e=this.terrain.probe(t,n);if(e.waterDepth>.012)return 0;const o=this.nearestVillageInfo(t,n),i=this.nearestRoadDistance(t,n),r=Math.max(this.config.settlement.minVillageDistance*.22,55),c=Math.max(this.config.settlement.minVillageDistance*1.05,r+80),d=Number.isFinite(o.distance)?1-F(r,c,o.distance):0,l=Math.max(this.config.settlement.minVillageDistance*.34,96),a=Number.isFinite(i)?1-F(B.forest.roadStart,l,i):0,h=F(.58,.97,e.shore)*B.forest.shorePenaltyWeight,g=this.fieldPressure(o,i),u=s*(1-d*B.forest.villagePenaltyWeight-a*B.forest.roadPenaltyWeight-g*B.forest.fieldPressureWeight)*(1-h)+e.moisture*B.forest.moistureWeight;return C(u,0,1)}fieldPressure(t,n){if(!Number.isFinite(t.distance)||t.radius<=0||!Number.isFinite(n))return 0;const s=t.radius*.96,e=t.radius*2.55;if(t.distance<s||t.distance>e)return 0;const o=(s+e)*.5,i=Math.max((e-s)*.5,1),r=C(1-Math.abs(t.distance-o)/i,0,1),c=1-F(22,Math.max(this.config.settlement.minVillageDistance*.44,140),n);return C(r*c,0,1)}nearestVillageInfo(t,n){const s=this.cacheKey(t,n),e=this.villageDistanceCache.get(s);if(e)return e;let o=Number.POSITIVE_INFINITY,i=0;for(const c of this.features.villages){const d=Math.hypot(t-c.x,n-c.y);d<o&&(o=d,i=c.radius)}const r={distance:o,radius:i};return this.villageDistanceCache.set(s,r),r}nearestRoadDistance(t,n){const s=this.cacheKey(t,n),e=this.roadDistanceCache.get(s);if(e!==void 0)return e;let o=Number.POSITIVE_INFINITY;for(const i of this.features.roads)for(let r=1;r<i.points.length;r+=1){const c=i.points[r-1],d=i.points[r],l=this.distanceToSegment(t,n,c.x,c.y,d.x,d.y)-i.width;l<o&&(o=l)}return this.roadDistanceCache.set(s,o),o}distanceToSegment(t,n,s,e,o,i){const r=o-s,c=i-e,d=r*r+c*c;if(d<=1e-6)return Math.hypot(t-s,n-e);const l=C(((t-s)*r+(n-e)*c)/d,0,1),a=s+r*l,h=e+c*l;return Math.hypot(t-a,n-h)}cacheKey(t,n){return`${Math.floor(t/rt)},${Math.floor(n/rt)}`}}const Ut=(f,t)=>`${f},${t}`;class Qt{constructor(t,n){this.cache=new Map,this.config=t,this.settlements=n}getFeaturesForChunk(t,n){const s=Math.max(1,this.config.chunk.superchunkSpanChunks|0),e=Math.floor(t/s),o=Math.floor(n/s),i=Ut(e,o),r=this.cache.get(i);if(r)return r.features;const c=this.config.chunk.pixelSize,d=s*c,l=e*d,a=o*d,h=l+d,g=a+d,u=this.config.chunk.featureMargin,p=this.settlements.getFeaturesForBounds(l-u,h+u,a-u,g+u);return this.cache.set(i,{key:i,features:p}),this.prune(),p}clear(){this.cache.clear()}prune(){const t=this.config.chunk.maxCachedSuperchunks;if(this.cache.size<=t)return;const n=this.cache.size-t,s=this.cache.keys();for(let e=0;e<n;e+=1){const o=s.next();if(o.done)break;this.cache.delete(o.value)}}}class Jt{constructor(t,n,s,e,o,i){this.config=t,this.terrain=n,this.debug=e,this.treeSeed=o,this.fieldSeed=i,this.superchunkCache=new Qt(t,s)}draw(t,n,s,e,o,i,r){if(this.debug.showWaterMask||this.debug.showMoisture||this.debug.showForestMask)return;const d=this.superchunkCache.getFeaturesForChunk(n,s),l=new Xt(this.config,this.terrain,d);this.drawFields(t,e,o,i,d,l),this.drawRoadsAndVillages(t,e,o,d,r),this.drawParcels(t,e,o,d.parcels),this.drawHouses(t,e,o,d),this.drawForest(t,e,o,i,l)}drawForest(t,n,s,e,o){const i=this.config.vegetation.treeGridSize,r=this.config.vegetation.treeRenderMargin,c=N(n-r,i),d=N(n+e+r,i),l=N(s-r,i),a=N(s+e+r,i),h=this.config.vegetation.forestDenseThreshold,g=this.config.vegetation.forestMinDensity,u=[],p=[];for(let w=l;w<=a;w+=1)for(let x=c;x<=d;x+=1){const M=P(this.treeSeed,x,w),k=S(L(M^2779993889)),R=S(L(M^4046232899)),I=x*i+k*i,H=w*i+R*i,D=this.terrain.forestDensityAt(I,H),v=o.forestSuitability(I,H,D);if(v<g)continue;const V=C((v-g)/(1-g),0,1);if(S(L(M^1831565813))>V*V)continue;const A=S(L(M^2654435769)),z=b(this.config.vegetation.treeMinRadius,this.config.vegetation.treeMaxRadius,v)*(.8+A*.5),E=S(L(M^1327217884)),j=I-n,q=H-s;v>=h?u.push({gx:x,gy:w,x:j,y:q,radius:z,alpha:C(.32+v*.34,.2,.7),shape:E}):p.push({x:j,y:q,radius:z*.72,alpha:C(.42+v*.3,.25,.7),shape:E})}const m=this.groupDenseTrees(u),y=[...p];for(const w of m){if(w.length<5){for(const M of w)y.push({x:M.x,y:M.y,radius:M.radius*.88,alpha:C(M.alpha+.08,.35,.78),shape:M.shape});continue}this.drawDenseForestMass(t,w);const x=new Set(w.map(M=>`${M.gx},${M.gy}`));for(const M of w)this.isDenseBoundaryTree(M.gx,M.gy,x)&&y.push({x:M.x,y:M.y,radius:M.radius*.82,alpha:C(M.alpha+.14,.38,.84),shape:M.shape})}for(const w of y)this.drawTreeSymbol(t,w.x,w.y,w.radius,w.shape,`rgba(119, 161, 141, ${w.alpha.toFixed(3)})`)}drawFields(t,n,s,e,o,i){const l=e+44,a=e+44,h=18;for(const g of o.villages){const u=g.radius*1.08,p=g.radius*2.28;for(let m=0;m<h;m+=1){const y=P(this.fieldSeed,g.cellX*97+m*13,g.cellY*89+m*17),w=S(y)*Math.PI*2,x=b(u,p,S(L(y^2654435769))),M=b(-20,20,S(L(y^2135587861))),k=g.x+Math.cos(w)*x+Math.cos(w+Math.PI*.5)*M,R=g.y+Math.sin(w)*x+Math.sin(w+Math.PI*.5)*M,I=i.fieldSuitabilityForVillage(k,R,g);if(I<.22||S(L(y^461845907))>I)continue;const D=b(26,68,S(L(y^3518319157))),v=b(16,40,S(L(y^2496678331))),V=Math.max(D,v)*.55+7;if(this.pointNearRoad(k,R,o.roads,V))continue;const T=k-n,A=R-s;if(T<-44||A<-44||T>l||A>a)continue;const z=S(L(y^2246822507)),E=S(L(y^3266489909)),j=w+b(-.6,.6,S(L(y^668265263))),q=Math.round(b(173,208,z)),X=Math.round(b(162,194,z)),Y=Math.round(b(126,148,z));t.save(),t.translate(T,A),t.rotate(j),t.fillStyle=`rgba(${q}, ${X}, ${Y}, 0.36)`,t.strokeStyle=`rgba(${Math.max(0,q-70)}, ${Math.max(0,X-62)}, ${Math.max(0,Y-48)}, 0.56)`,t.lineWidth=1.3,t.fillRect(-D*.5,-v*.5,D,v),t.strokeRect(-D*.5,-v*.5,D,v);const K=Math.max(2,Math.floor(v/6)),_=b(.22,.36,E);t.strokeStyle=`rgba(104, 84, 52, ${_.toFixed(3)})`,t.lineWidth=1.1;for(let Z=1;Z<K;Z+=1){const U=-v*.5+v*Z/K;t.beginPath(),t.moveTo(-D*.45,U),t.lineTo(D*.45,U),t.stroke()}t.restore()}}}drawTreeSymbol(t,n,s,e,o,i){const r=Math.max(2.4,e),c=4+Math.floor(o*3),d=o*Math.PI*2,l=r*.58;t.fillStyle=i,t.beginPath();for(let a=0;a<c;a+=1){const h=d+a/c*Math.PI*2,g=r*(.84+(a+1)%2*.18),u=n+Math.cos(h)*g*.5,p=s+Math.sin(h)*g*.42;a===0?t.moveTo(u,p):t.lineTo(u,p)}t.closePath(),t.fill(),t.strokeStyle="rgba(14, 18, 16, 0.9)",t.lineWidth=1.4,t.stroke(),t.fillStyle="rgba(177, 205, 183, 0.34)",t.beginPath(),t.arc(n-r*.22,s-r*.18,l,0,Math.PI*2),t.fill()}groupDenseTrees(t){const n=new Map;for(const i of t)n.set(`${i.gx},${i.gy}`,i);const s=new Set,e=[],o=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];for(const i of t){const r=`${i.gx},${i.gy}`;if(s.has(r))continue;const c=[i];s.add(r);const d=[];for(;c.length>0;){const l=c.pop();if(!l)break;d.push(l);for(const a of o){const h=l.gx+a[0],g=l.gy+a[1],u=`${h},${g}`;if(s.has(u))continue;const p=n.get(u);p&&(s.add(u),c.push(p))}}e.push(d)}return e}isDenseBoundaryTree(t,n,s){for(let e=-1;e<=1;e+=1)for(let o=-1;o<=1;o+=1)if(!(o===0&&e===0)&&!s.has(`${t+o},${n+e}`))return!0;return!1}drawDenseForestMass(t,n){const s=n.map(a=>({x:a.x,y:a.y})),e=this.convexHull(s);if(e.length<3)return;let o=0,i=0;for(const a of e)o+=a.x,i+=a.y;o/=e.length,i/=e.length;const r=n.reduce((a,h)=>a+h.radius,0)/n.length,c=e.map(a=>{const h=a.x-o,g=a.y-i,u=Math.hypot(h,g);if(u<=1e-6)return a;const p=Math.max(6,r*.95);return{x:a.x+h/u*p,y:a.y+g/u*p}});t.fillStyle="rgba(84, 118, 103, 0.88)",t.strokeStyle="rgba(11, 14, 12, 0.84)",t.lineWidth=2,t.beginPath();for(let a=0;a<c.length;a+=1){const h=c[a],g=c[(a+1)%c.length],u=(h.x+g.x)*.5,p=(h.y+g.y)*.5;a===0?t.moveTo(u,p):t.quadraticCurveTo(h.x,h.y,u,p)}const d=c[0],l=c[1%c.length];t.quadraticCurveTo(d.x,d.y,(d.x+l.x)*.5,(d.y+l.y)*.5),t.closePath(),t.fill(),t.stroke()}convexHull(t){if(t.length<4)return t.slice();const n=t.slice().sort((o,i)=>o.x===i.x?o.y-i.y:o.x-i.x),s=[];for(const o of n){for(;s.length>=2&&this.cross2(s[s.length-2],s[s.length-1],o)<=0;)s.pop();s.push(o)}const e=[];for(let o=n.length-1;o>=0;o-=1){const i=n[o];for(;e.length>=2&&this.cross2(e[e.length-2],e[e.length-1],i)<=0;)e.pop();e.push(i)}return e.pop(),s.pop(),s.concat(e)}cross2(t,n,s){return(n.x-t.x)*(s.y-t.y)-(n.y-t.y)*(s.x-t.x)}pointNearRoad(t,n,s,e){const o=e*e;for(const i of s)for(let r=1;r<i.points.length;r+=1){const c=i.points[r-1],d=i.points[r],l=this.distanceSqToSegment(t,n,c.x,c.y,d.x,d.y),a=i.width+2;if(l<=o+a*a)return!0}return!1}distanceSqToSegment(t,n,s,e,o,i){const r=o-s,c=i-e,d=r*r+c*c;if(d<=1e-6){const p=t-s,m=n-e;return p*p+m*m}const l=C(((t-s)*r+(n-e)*c)/d,0,1),a=s+r*l,h=e+c*l,g=t-a,u=n-h;return g*g+u*u}drawRoadsAndVillages(t,n,s,e,o){if(!(!this.debug.showRoads&&!this.debug.showVillages)){if(this.debug.showRoads){const i=[];for(const r of e.roads)r.points.length<2||this.drawRoadSegments(t,r,n,s,o,i);i.length>0&&this.drawBridges(t,n,s,i)}this.debug.showVillages&&this.drawVillageMarkers(t,n,s,e.villages)}}drawRoadSegments(t,n,s,e,o,i){t.lineCap="round",t.lineJoin="round";for(let r=1;r<n.points.length;r+=1){const c=n.points[r-1],d=n.points[r],l=this.collectBridgeCuts(c.x,c.y,d.x,d.y,n.width,o,i);if(l.length===0){this.strokeRoadSegment(t,n,c.x,c.y,d.x,d.y,s,e);continue}let a=0;for(const h of l)h.startT>a+.03&&this.strokeRoadSegment(t,n,b(c.x,d.x,a),b(c.y,d.y,a),b(c.x,d.x,h.startT),b(c.y,d.y,h.startT),s,e),a=Math.max(a,h.endT);a<.97&&this.strokeRoadSegment(t,n,b(c.x,d.x,a),b(c.y,d.y,a),d.x,d.y,s,e)}}strokeRoadPath(t,n){t.strokeStyle="rgba(8, 10, 11, 0.88)",t.lineWidth=n.width+(n.type==="local"?2.2:2.9),t.stroke(),t.strokeStyle=n.type==="major"?"rgba(223, 211, 169, 0.98)":n.type==="minor"?"rgba(210, 201, 163, 0.96)":"rgba(205, 198, 170, 0.94)",t.lineWidth=n.width,t.stroke()}strokeRoadSegment(t,n,s,e,o,i,r,c){t.beginPath(),t.moveTo(s-r,e-c),t.lineTo(o-r,i-c),this.strokeRoadPath(t,n)}collectBridgeCuts(t,n,s,e,o,i,r){const c=s-t,d=e-n,l=Math.hypot(c,d);if(l<=1e-6)return[];const a=[];for(const u of i)for(let p=1;p<u.points.length;p+=1){const m=u.points[p-1],y=u.points[p],w=this.segmentIntersection(t,n,s,e,m.x,m.y,y.x,y.y);if(!w)continue;const x=C(u.width*.9+o*1.55,6,26),M=C(w.t-x/l,0,1),k=C(w.t+x/l,0,1);a.push({startT:M,endT:k});const R={x1:b(t,s,M),y1:b(n,e,M),x2:b(t,s,k),y2:b(n,e,k),width:o};this.hasNearbyBridge(r,R)||r.push(R)}const h=this.sampleTerrainWaterCut(t,n,s,e);if(h){a.push(h);const u={x1:b(t,s,h.startT),y1:b(n,e,h.startT),x2:b(t,s,h.endT),y2:b(n,e,h.endT),width:o};this.hasNearbyBridge(r,u)||r.push(u)}if(a.length===0)return[];a.sort((u,p)=>u.startT-p.startT);const g=[a[0]];for(let u=1;u<a.length;u+=1){const p=a[u],m=g[g.length-1];p.startT<=m.endT+.03?m.endT=Math.max(m.endT,p.endT):g.push(p)}return g}sampleTerrainWaterCut(t,n,s,e){let r=-1,c=-1;for(let d=1;d<8;d+=1){const l=d/8,a=b(t,s,l),h=b(n,e,l);if(this.terrain.sample(a,h).waterDepth>.002)r<0&&(r=l),c=l;else if(r>=0)break}return r<0||c<0||c-r<.06?null:{startT:C(r-.08,0,1),endT:C(c+.08,0,1)}}segmentIntersection(t,n,s,e,o,i,r,c){const d=s-t,l=e-n,a=r-o,h=c-i,g=d*h-l*a;if(Math.abs(g)<=1e-6)return null;const u=o-t,p=i-n,m=(u*h-p*a)/g,y=(u*l-p*d)/g;return m<0||m>1||y<0||y>1?null:{t:m,x:t+d*m,y:n+l*m}}hasNearbyBridge(t,n){const s=(n.x1+n.x2)*.5,e=(n.y1+n.y2)*.5;for(const o of t){const i=(o.x1+o.x2)*.5,r=(o.y1+o.y2)*.5;if(Math.hypot(s-i,e-r)<5)return!0}return!1}drawBridges(t,n,s,e){for(const o of e){const i=o.x2-o.x1,r=o.y2-o.y1,c=Math.hypot(i,r);if(c<=1e-4)continue;const d=(o.x1+o.x2)*.5-n,l=(o.y1+o.y2)*.5-s,a=Math.atan2(r,i),h=o.width+1.4,g=h*.46;t.save(),t.translate(d,l),t.rotate(a),t.strokeStyle="rgba(10, 12, 12, 0.9)",t.lineWidth=h+2.4,t.lineCap="round",t.beginPath(),t.moveTo(-c*.5,0),t.lineTo(c*.5,0),t.stroke(),t.strokeStyle="rgba(216, 192, 152, 0.98)",t.lineWidth=h,t.beginPath(),t.moveTo(-c*.5,0),t.lineTo(c*.5,0),t.stroke(),t.strokeStyle="rgba(13, 14, 13, 0.8)",t.lineWidth=1,t.beginPath(),t.moveTo(-c*.48,-g),t.lineTo(c*.48,-g),t.moveTo(-c*.48,g),t.lineTo(c*.48,g),t.stroke(),t.strokeStyle="rgba(76, 57, 37, 0.46)";for(let u=-c*.5+2;u<c*.5-2;u+=4)t.beginPath(),t.moveTo(u,-h*.4),t.lineTo(u,h*.4),t.stroke();t.restore()}}drawVillageMarkers(t,n,s,e){for(const o of e){const i=o.x-n,r=o.y-s,c=C(o.radius*.07,3,6);t.fillStyle="rgba(244, 230, 186, 0.92)",t.beginPath(),t.arc(i,r,c,0,Math.PI*2),t.fill(),t.strokeStyle="rgba(10, 14, 12, 0.9)",t.lineWidth=1.4,t.stroke(),t.beginPath(),t.moveTo(i-c*1.4,r),t.lineTo(i+c*1.4,r),t.moveTo(i,r-c*1.4),t.lineTo(i,r+c*1.4),t.lineWidth=1,t.stroke()}}drawParcels(t,n,s,e){if(this.debug.showParcels)for(const o of e){const i=o.x-n,r=o.y-s;t.save(),t.translate(i,r),t.rotate(o.angle),t.fillStyle="rgba(211, 218, 167, 0.28)",t.strokeStyle="rgba(11, 15, 13, 0.82)",t.lineWidth=1.2,t.fillRect(-o.width*.5,-o.depth*.5,o.width,o.depth),t.strokeRect(-o.width*.5,-o.depth*.5,o.width,o.depth),t.restore()}}drawHouses(t,n,s,e){if(this.debug.showHouses)for(const o of e.houses)this.drawHouse(t,n,s,o)}drawHouse(t,n,s,e){const o=e.x-n,i=e.y-s,r=[{roof:"#907367",wall:"#c3b59d"},{roof:"#6f7680",wall:"#b7b8b0"},{roof:"#8f6654",wall:"#c2b19e"},{roof:"#7d6f5f",wall:"#bbb09f"}],c=r[e.roofStyle%r.length];t.save(),t.translate(o,i),t.rotate(e.angle),t.fillStyle="rgba(25, 33, 38, 0.2)",t.fillRect(-e.width*.55+1.5,-e.depth*.5+2.5,e.width,e.depth),t.fillStyle=c.wall,t.strokeStyle="rgba(8, 10, 10, 0.9)",t.lineWidth=1.3,t.fillRect(-e.width*.5,-e.depth*.5,e.width,e.depth),t.strokeRect(-e.width*.5,-e.depth*.5,e.width,e.depth),t.fillStyle=c.roof,t.fillRect(-e.width*.6,-e.depth*.52,e.width*1.2,e.depth*.58),t.strokeRect(-e.width*.6,-e.depth*.52,e.width*1.2,e.depth*.58),t.strokeStyle="rgba(14, 11, 9, 0.64)",t.beginPath(),t.moveTo(-e.width*.55,-e.depth*.4),t.lineTo(e.width*.55,-e.depth*.4),t.stroke(),t.restore()}}const O=f=>Math.max(0,Math.min(255,Math.round(f)));class _t{constructor(t,n,s){this.config=t,this.terrain=n,this.colorSampler=s}render(t,n,s,e,o,i){const r=this.buildRiverSegments(i);if(o===1){this.renderFullResolution(t,n,s,e,r);return}this.renderBlockSampled(t,n,s,e,o,r)}renderFullResolution(t,n,s,e,o){const i=t.createImageData(e,e),r=i.data;let c=0;for(let d=0;d<e;d+=1)for(let l=0;l<e;l+=1){const a=n+l,h=s+d,g=this.sampleUnifiedWater(a,h,o),u=this.colorSampler.sample(a,h,g);r[c]=O(u.r),r[c+1]=O(u.g),r[c+2]=O(u.b),r[c+3]=255,c+=4}t.putImageData(i,0,0)}renderBlockSampled(t,n,s,e,o,i){const r=t.createImageData(e,e),c=r.data;for(let d=0;d<e;d+=o)for(let l=0;l<e;l+=o){const a=Math.min(o,e-l),h=Math.min(o,e-d),g=n+l+o*.5,u=s+d+o*.5,p=this.sampleUnifiedWater(g,u,i);if(p.shore>.14){for(let k=0;k<h;k+=1)for(let R=0;R<a;R+=1){const I=l+R,H=d+k,D=n+I+.5,v=s+H+.5,V=this.sampleUnifiedWater(D,v,i),T=this.colorSampler.sample(D,v,V),A=(H*e+I)*4;c[A]=O(T.r),c[A+1]=O(T.g),c[A+2]=O(T.b),c[A+3]=255}continue}const y=this.colorSampler.sample(g,u,p),w=O(y.r),x=O(y.g),M=O(y.b);for(let k=0;k<h;k+=1)for(let R=0;R<a;R+=1){const I=l+R,D=((d+k)*e+I)*4;c[D]=w,c[D+1]=x,c[D+2]=M,c[D+3]=255}}t.putImageData(r,0,0)}sampleUnifiedWater(t,n,s){const e=this.terrain.sample(t,n);if(s.length===0)return e;const o=1.4;let i=e.waterDepth,r=0;for(const d of s){if(t<d.minX-o||t>d.maxX+o||n<d.minY-o||n>d.maxY+o)continue;const l=this.distanceToSegment(t,n,d.ax,d.ay,d.bx,d.by);if(!(l>d.halfWidth+o)){if(l<=d.halfWidth){const a=1-C(l/Math.max(d.halfWidth,.001),0,1),h=Math.min(.048,this.config.terrain.shoreBand*.92),g=.003+a*h;g>i&&(i=g,r=Math.max(r,.16*a+.06))}else if(e.waterDepth<=.0015){const a=1-C((l-d.halfWidth)/o,0,1),h=a*.0018;h>i&&(i=h,r=Math.max(r,.05*a))}}}if(i<=e.waterDepth+1e-6)return e;const c=1-C(Math.abs(i)/this.config.terrain.shoreBand,0,1);return{elevation:e.elevation,moisture:C(e.moisture+r,0,1),waterDepth:i,shore:Math.max(e.shore,c)}}buildRiverSegments(t){const n=[];for(const s of t){if(s.points.length<2)continue;const e=Math.max(1.4,s.width*.5);for(let o=1;o<s.points.length;o+=1){const i=s.points[o-1],r=s.points[o];n.push({ax:i.x,ay:i.y,bx:r.x,by:r.y,halfWidth:e,minX:Math.min(i.x,r.x),maxX:Math.max(i.x,r.x),minY:Math.min(i.y,r.y),maxY:Math.max(i.y,r.y)})}}return n}distanceToSegment(t,n,s,e,o,i){const r=o-s,c=i-e,d=r*r+c*c;if(d<=1e-6)return Math.hypot(t-s,n-e);const l=C(((t-s)*r+(n-e)*c)/d,0,1),a=s+r*l,h=e+c*l;return Math.hypot(t-a,n-h)}}class Zt{constructor(t,n,s,e,o,i,r,c){this.config=t,this.rivers=s,this.debug=o;const d=new Kt(t,n,o,i);this.terrainSurface=new _t(t,n,d),this.overlays=new Jt(t,n,e,o,r,c)}renderChunk(t,n){const s=this.config.chunk.pixelSize,e=Math.max(1,this.config.chunk.sampleStep|0),o=t*s,i=n*s,r=this.getRiversForChunk(o,i,s),c=document.createElement("canvas");c.width=s,c.height=s;const d=c.getContext("2d");if(!d)throw new Error("2D canvas context unavailable.");return this.terrainSurface.render(d,o,i,s,e,r),this.overlays.draw(d,t,n,o,i,s,r),c}getRiversForChunk(t,n,s){if(!this.debug.showRivers)return[];const e=48;return this.rivers.getRiversForBounds(t-e,t+s+e,n-e,n+s+e)}}class te{constructor(t){this.warningCount=0,this.config=t}getWarningCount(){return this.warningCount}validate(t,n,s){if(!this.config.chunk.enableSeamValidation)return;const e=s(t,n);if(!e)return;const o=s(t-1,n);o&&this.compareVertical(o,e,t,n);const i=s(t,n-1);i&&this.compareHorizontal(i,e,t,n)}compareVertical(t,n,s,e){const o=this.config.chunk.seamColorTolerance,i=Math.min(t.width,n.width),r=Math.min(t.height,n.height);if(i<1||r<1)return;const c=t.getContext("2d"),d=n.getContext("2d");if(!c||!d)return;const l=c.getImageData(i-1,0,1,r).data,a=d.getImageData(0,0,1,r).data;let h=0;for(let u=0;u<l.length;u+=4)h+=Math.abs(l[u]-a[u]),h+=Math.abs(l[u+1]-a[u+1]),h+=Math.abs(l[u+2]-a[u+2]);const g=h/Math.max(1,r*3);g<=o||(this.warningCount+=1,this.warningCount<=14&&console.warn(`Seam mismatch (vertical) at chunk ${s-1},${e} -> ${s},${e}: avg RGB diff ${g.toFixed(2)}`))}compareHorizontal(t,n,s,e){const o=this.config.chunk.seamColorTolerance,i=Math.min(t.width,n.width),r=Math.min(t.height,n.height);if(i<1||r<1)return;const c=t.getContext("2d"),d=n.getContext("2d");if(!c||!d)return;const l=c.getImageData(0,r-1,i,1).data,a=d.getImageData(0,0,i,1).data;let h=0;for(let u=0;u<l.length;u+=4)h+=Math.abs(l[u]-a[u]),h+=Math.abs(l[u+1]-a[u+1]),h+=Math.abs(l[u+2]-a[u+2]);const g=h/Math.max(1,i*3);g<=o||(this.warningCount+=1,this.warningCount<=14&&console.warn(`Seam mismatch (horizontal) at chunk ${s},${e-1} -> ${s},${e}: avg RGB diff ${g.toFixed(2)}`))}}const at=(f,t)=>`${f},${t}`,ct=()=>typeof performance<"u"?performance.now():Date.now();class ee{constructor(t){this.chunkCache=new Map,this.pendingQueue=[],this.pendingSet=new Set,this.getReadyChunkCanvas=(r,c)=>{const d=this.chunkCache.get(at(r,c));return!d||d.status!=="ready"?null:d.canvas},this.config=t,this.terrain=et(t);const n=new ht(t,this.terrain),s=new lt(t,this.terrain);this.debug={...t.debug};const e=W(`${t.seed}:surface`),o=W(`${t.seed}:trees`),i=W(`${t.seed}:fields`);this.chunkRenderer=new Zt(t,this.terrain,n,s,this.debug,e,o,i),this.seamValidator=new te(t),this.placeholderCanvas=this.createPlaceholderChunkCanvas(t.chunk.pixelSize)}getSeed(){return this.config.seed}getChunkSize(){return this.config.chunk.pixelSize}getDebugLayers(){return{...this.debug}}toggleDebugLayer(t){this.debug[t]=!this.debug[t],this.chunkCache.clear(),this.pendingSet.clear(),this.pendingQueue.length=0}sampleAt(t,n){return this.terrain.probe(t,n)}getWorldHandshake(){return ut(this.config)}getSerializedWorldHandshake(){return Ot(this.getWorldHandshake())}advanceGenerationBudget(){const t=Math.max(.2,this.config.chunk.generationBudgetMs),n=Math.max(1,this.config.chunk.maxChunkBuildsPerFrame|0),s=ct();let e=0;for(;e<n&&this.pendingQueue.length>0&&!(ct()-s>t);){const o=this.pendingQueue.shift();if(!o)break;this.pendingSet.delete(o);const i=this.chunkCache.get(o);!i||i.status==="ready"||(i.canvas=this.chunkRenderer.renderChunk(i.x,i.y),i.status="ready",e+=1,this.seamValidator.validate(i.x,i.y,this.getReadyChunkCanvas))}}getGenerationStats(){return{pendingChunks:this.pendingSet.size,seamWarnings:this.seamValidator.getWarningCount()}}getChunkCanvas(t,n){return this.getChunk(t,n,!0).canvas}prefetchChunksNearPlayer(t,n,s,e,o,i){const r=this.config.chunk.pixelSize,c=1;this.ensureChunkRange(N(t-s*.5,r)-c,N(t+s*.5,r)+c,N(n-e*.5,r)-c,N(n+e*.5,r)+c,!1);const d=Math.hypot(o,i);if(d<.12)return;const l=o/d,a=i/d,h=Math.max(0,this.config.chunk.prefetchLookaheadChunks|0),g=Math.max(0,this.config.chunk.prefetchLateralChunks|0);if(h===0&&g===0)return;const u=t+l*h*r,p=n+a*h*r,m=s*.5+g*r,y=e*.5+g*r;this.ensureChunkRange(N(u-m,r),N(u+m,r),N(p-y,r),N(p+y,r),!1)}getChunk(t,n,s){const e=at(t,n),o=this.chunkCache.get(e);if(o&&s&&o.status==="pending"&&this.enqueueChunkGeneration(e,!0),o)return o;const i={x:t,y:n,canvas:this.placeholderCanvas,status:"pending"};return this.chunkCache.set(e,i),this.enqueueChunkGeneration(e,s),this.pruneCache(),i}enqueueChunkGeneration(t,n){if(this.pendingSet.has(t)){if(n){const s=this.pendingQueue.indexOf(t);s>0&&(this.pendingQueue.splice(s,1),this.pendingQueue.unshift(t))}return}this.pendingSet.add(t),n?this.pendingQueue.unshift(t):this.pendingQueue.push(t)}ensureChunkRange(t,n,s,e,o){for(let i=s;i<=e;i+=1)for(let r=t;r<=n;r+=1)this.getChunk(r,i,o)}pruneCache(){const t=this.config.chunk.maxCachedChunks;if(this.chunkCache.size<=t)return;const n=this.chunkCache.size-t,s=this.chunkCache.keys();for(let e=0;e<n;e+=1){const o=s.next();if(o.done)break;const i=o.value;this.chunkCache.delete(i),this.pendingSet.delete(i)}}createPlaceholderChunkCanvas(t){const n=document.createElement("canvas");n.width=t,n.height=t;const s=n.getContext("2d");if(!s)return n;s.fillStyle="#8fa486",s.fillRect(0,0,t,t),s.strokeStyle="rgba(65, 76, 60, 0.36)",s.lineWidth=1;const e=16;for(let o=-t;o<t*2;o+=e)s.beginPath(),s.moveTo(o,0),s.lineTo(o-t,t),s.stroke();return n}}const ne=()=>{const f=document.querySelector("#game"),t=document.querySelector("#hud");if(!f||!t)throw new Error("Missing #game canvas or #hud element.");const n=new URLSearchParams(window.location.search),s=n.get("seed")??"12345abcde",e=Number(n.get("chunkSize")??"320"),o=Number(n.get("seaLevel")??"NaN"),i=Number(n.get("sampleStep")??"2"),r=Number(n.get("superchunkSpan")??"NaN"),c=Number(n.get("genBudgetMs")??"NaN"),d=Number(n.get("maxChunkBuilds")??"NaN"),l=Number(n.get("prefetchLookahead")??"NaN"),a=Number(n.get("prefetchLateral")??"NaN"),h=n.get("seamValidation"),g=n.get("determinism"),u=Number(n.get("determinismRuns")??"3"),p=mt(s);Number.isFinite(e)&&e>=180&&e<=640&&(p.chunk.pixelSize=e),Number.isFinite(o)&&o>=.3&&o<=.68&&(p.terrain.seaLevel=o),Number.isFinite(i)&&i>=1&&i<=8&&(p.chunk.sampleStep=Math.floor(i)),Number.isFinite(r)&&r>=1&&r<=8&&(p.chunk.superchunkSpanChunks=Math.floor(r)),Number.isFinite(c)&&c>=.5&&c<=24&&(p.chunk.generationBudgetMs=c),Number.isFinite(d)&&d>=1&&d<=8&&(p.chunk.maxChunkBuildsPerFrame=Math.floor(d)),Number.isFinite(l)&&l>=0&&l<=8&&(p.chunk.prefetchLookaheadChunks=Math.floor(l)),Number.isFinite(a)&&a>=0&&a<=6&&(p.chunk.prefetchLateralChunks=Math.floor(a)),h==="0"||h==="false"?p.chunk.enableSeamValidation=!1:(h==="1"||h==="true")&&(p.chunk.enableSeamValidation=!0);const m=new ee(p);if(g==="1"||g==="true"){const w=Yt(p,Number.isFinite(u)?u:3);console.info("Determinism suite result",w)}new pt(f,t,m).start()};try{ne()}catch(f){const t=f instanceof Error?f.message:String(f);document.body.innerHTML=`<pre style="color:#fff;padding:16px">${t}</pre>`}
